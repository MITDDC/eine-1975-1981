;;; LISP Machine DDT.   DLW 6/6/77  -*-LISP-*-

(SETQ DDT '((SPECIAL-PROCESSING (SEND-MACROS-OVER))
	    (SET-PROCESS-SWITCH RETAIN-VARIABLE-NAMES-SWITCH 'ALL)
	    DDT-INIT-TABLES DDT-SETUP-DISPATCH-TABLE
	    DDT-CREATE-QN DDT-INITIALIZE-QN DDT-SET-QN DDT-SET-POINT DDT-BARF
	    DDT DDT-INITIALIZE DDT-STANDARD-TYPE-OUT DDT-TOP-LEVEL
	    DDT-NEXT-TOKEN DDT-GET-SYNTAX DDT-SUBSTRING DDT-EVAL-NEXT-TOKEN
	    DDT-EVAL DDT-ADD-ON DDT-EXAMINE DDT-DEPOSIT
	    DDT-CMD-UNDERSCORE DDT-CMD-BACKSLASH DDT-CMD-SLASH
	    DDT-CMD-RETURN DDT-CMD-LINE DDT-CMD-UPARROW
	    DDT-RESET-TEMPORARY-MODE DDT-STANDARD-TYPE-OUT
	    (SPECIAL-PROCESSING (LOAD-TIME-SETQ
				 DDT-SYNTAX-RUBOUT -1
				 DDT-SYNTAX-CLEAR-SCREEN -2
				 DDT-SYNTAX-FLUSH-TYPEIN -3
				 DDT-SYNTAX-BREAK -4
				 DDT-SYNTAX-ALPHANUMERIC -5
		   ;***** IF YOU ADD TO THIS, ADD BELOW ALSO, TO DECLARE IT SPECIAL. *****
				 DDT-ARTIFICIAL-POINTER-LIST '(DDT-DTP-ERROR "ERROR"
							       DDT-DTP-ARG "ARG"
							       DDT-DTP-LOCAL "LOCAL" 
							       DDT-DTP-INSN "INSN"
							       DDT-DTP-MACRO "MACRO"
							       DDT-DTP-ARRAY "ARRAY" ;?
							       )
				 ))
	    ))

(SPECIAL						;Special quantities.
 DDT-POINT
 DDT-POINT-RING
 DDT-READIN-QN
 DDT-ALT-Q
 DDT-ALT-Q-RING
 DDT-OPEN-QN
 DDT-OPEN-P

;Codes for artificial pointers.
;These live in the DDT-QN-DTP and so must be greater than the maximum datatype.
;***** IF YOU ADD MORE, UPDATE THE LIST WHICH IS LOAD-TIME-SETQED TO THEM. *****
 DDT-DTP-ERROR
 DDT-DTP-ARG
 DDT-DTP-LOCAL
 DDT-DTP-INSN
 DDT-DTP-MACRO
 DDT-DTP-ARRAY

 DDT-ARTIFICIAL-POINTER-LIST
 DDT-ARTIFICIAL-POINTER-ARRAY

 DDT-SYNTAX-RUBOUT 
 DDT-SYNTAX-CLEAR-SCREEN 
 DDT-SYNTAX-FLUSH-TYPEIN 
 DDT-SYNTAX-BREAK 
 DDT-SYNTAX-ALPHANUMERIC 

 DDT-CURRENT-TYPE-OUT-MODE
 DDT-PERMANENT-TYPE-OUT-MODE
; DDT-TEMPORARY-TYPE-OUT-MODE ;ANY USE FOR THIS?

 DDT-COMMAND-DISPATCH-TABLE
 DDT-INITIAL-COMMAND-DISPATCH-TABLE
 DDT-RPCNT

 DDT-READER-STRING
 DDT-READER-SUBSTRING
 DDT-SCANNER-POINTER

 DDT-OUTPUT-RADIX
 DDT-INPUT-RADIX
 DDT-LOCAL-SYMBOL-LIST
 DDT-PC-PPR
 )

;;; Code for hacking with QNs.

(DEFSTRUCT (DDT-QN) LIST				;Definition of a QN.
     DDT-QN-DTP						;Fixnum, contents of datatype field.
     DDT-QN-POINTER					;Fixnum or locative pointer to storage.
     DDT-QN-OFFSET					;Fixnum offset.
     )							;NOTE: The value of a FIXNUM is in the
     							;   OFFSET, not the POINTER.

(MACRO DDT-QN-P (X)					;Datatype check, sort of.
       (RPLACA X 'LISTP)
       X)

(DEFUN DDT-CREATE-QN ()					;Cons up a new QN.
   (DDT-QN DDT-QN-DTP DDT-DTP-ERROR
	   DDT-QN-POINTER NIL
	   DDT-QN-OFFSET 0))

(DEFUN DDT-INITIALIZE-QN (QN)				;Reset a QN.
    (SETF (DDT-QN-DTP QN) DDT-DTP-ERROR)
    (SETF (DDT-QN-POINTER QN) NIL)
    (SETF (DDT-QN-OFFSET QN) 0))

(DEFUN DDT-SET-QN (QN FROM)
    (SETF (DDT-QN-DTP QN) (DDT-QN-DTP FROM))
    (SETF (DDT-QN-POINTER QN) (DDT-QN-POINTER FROM))
    (SETF (DDT-QN-OFFSET QN) (DDT-QN-OFFSET FROM)))

(DEFUN DDT-SET-POINT (QN)
    (DDT-SET-QN DDT-POINT QN))

;;; Random utilities.

(DEFUN DDT-BARF (&EVAL &REST ARGS)
    (TV-BEEP)
    (MAPC (FUNCTION PRINC) ARGS)
    (ERROR "DDT barf.")
    (%THROW 'TOP-LEVEL T))


(DEFUN DDT ()
    (OR (BOUNDP 'DDT-DTP-ERROR)
	(DDT-INITIALIZE))
    (DDT-TOP-LEVEL))

; One-time initialization function.  Should set up all specials.

(DEFUN DDT-INITIALIZE ()
    (DDT-INIT-TABLES)
; -- Set ALL special variables to some known thing.
    (SETQ DDT-DTP-ERROR -1	     ;Must be set up so initialization of QNs works
          DDT-POINT-RING NIL
	  DDT-ALT-Q-RING NIL
	  DDT-INPUT-RADIX 8
	  DDT-OUTPUT-RADIX 8

	  DDT-CURRENT-TYPE-OUT-MODE   (FUNCTION-EVAL 'DDT-STANDARD-TYPE-OUT)
	  DDT-PERMANENT-TYPE-OUT-MODE (FUNCTION-EVAL 'DDT-STANDARD-TYPE-OUT)

	  DDT-POINT (DDT-CREATE-QN)
	  DDT-ALT-Q (DDT-CREATE-QN)
	  DDT-READIN-QN (DDT-CREATE-QN)
	  DDT-OPEN-QN (DDT-CREATE-QN)
	  DDT-OPEN-P NIL
	  DDT-LOCAL-SYMBOL-LIST (LIST (CONS "Q" DDT-ALT-Q) (CONS "." DDT-POINT))

	  DDT-PC-PPR CONSOLE-IO-PC-PPR
	  DDT-READER-STRING (MAKE-ARRAY-BLOCK DEFAULT-ARRAY-AREA ART-STRING 200 NIL '(0))
	  DDT-READER-SUBSTRING (MAKE-ARRAY-BLOCK DEFAULT-ARRAY-AREA ART-STRING 4
						DDT-READER-STRING NIL 0)

	  DDT-COMMAND-DISPATCH-TABLE
	         (MAKE-ARRAY-BLOCK DEFAULT-ARRAY-AREA ART-Q (LIST 6 160))
	  ) ;end of SETQ
    (DDT-SETUP-DISPATCH-TABLE DDT-COMMAND-DISPATCH-TABLE DDT-INITIAL-COMMAND-DISPATCH-TABLE)

    (SETQ DDT-ARTIFICIAL-POINTER-ARRAY
	  (MAKE-ARRAY-BLOCK DEFAULT-ARRAY-AREA
			    ART-Q
			    (1+ (// (LENGTH DDT-ARTIFICIAL-POINTER-LIST) 2))))
    (DO ((L DDT-ARTIFICIAL-POINTER-LIST (CDDR L))
	 (I -1 (1- I)))
	((NULL L))
      (SET (CAR L) I)
      (AS-1 (CADR L) DDT-ARTIFICIAL-POINTER-ARRAY (MINUS I))
      (SETQ DDT-LOCAL-SYMBOL-LIST (CONS
				   (CONS (CADR L)
					 (DDT-QN DDT-QN-DTP I DDT-QN-OFFSET 0))
				   DDT-LOCAL-SYMBOL-LIST))
      )
    )

(DEFUN DDT-SETUP-DISPATCH-TABLE (TABLE LISTS &AUX ENTRY TEM)
   (DO ((LISTS1 LISTS (CDR LISTS1))
	(IDX1 0 (1+ IDX1)))
       ((NULL LISTS1))
     (DO ((LIST (CAR LISTS1) (CDR LIST))
	  (IDX2 0))				  ;THE AMOUNT THIS IS INCREMENTED DEPENDS!!
	 ((NULL LIST) (COND ((NEQ IDX2 160)
			     (MAPC (FUNCTION PRINC)
				   (LIST "ROW WRONG SIZE: "
					 IDX1 " " IDX2 " --- DDT-SETUP-DISPATCH-TABLE"))
			     (TERPRI))))
       (SETQ ENTRY (CAR LIST))
       (COND ((OR (ATOM ENTRY)
		  (EQ (FIRST ENTRY) 'QUOTE))
	      (AS-2 (EVAL ENTRY) TABLE IDX1 IDX2)
	      (SETQ IDX2 (1+ IDX2)))
	     ((MEMQ (FIRST ENTRY) '(*REPEAT *REPEAT-EVAL))
	      (SETQ TEM (SECOND ENTRY))
	      (SETQ ENTRY (THIRD ENTRY))
	      (DO DDT-RPCNT 0 (1+ DDT-RPCNT) (= DDT-RPCNT TEM)
		(AS-2 (EVAL ENTRY) TABLE IDX1 IDX2)
		(SETQ IDX2 (1+ IDX2))))
	     ((EQ (FIRST ENTRY) '*EVAL)
	      (AS-2 (EVAL (SECOND ENTRY)) TABLE IDX1 IDX2)
	      (SETQ IDX2 (1+ IDX2)))
	     (T
	      (AS-2 (EVAL ENTRY) TABLE IDX1 IDX2)
	      (SETQ IDX2 (1+ IDX2)))))))

; Type out stuff.

(DEFUN DDT-TYPE-OUT (QN)
    (FUNCALL DDT-CURRENT-TYPE-OUT-MODE QN))

(DEFUN DDT-RESET-TEMPORARY-MODE ()
    (SETQ DDT-CURRENT-TYPE-OUT-MODE DDT-PERMANENT-TYPE-OUT-MODE))

; Standard typeout of a QN as a LISP pointer or whatever.  Tries to be clever.

(DEFUN DDT-STANDARD-TYPE-OUT (QN &AUX DTP PTR OFFSET (BASE DDT-OUTPUT-RADIX))
    (DDT-SET-QN DDT-ALT-Q QN)
    (SETQ DTP (DDT-QN-DTP QN)
	  PTR (DDT-QN-POINTER QN)
	  OFFSET (DDT-QN-OFFSET QN))
    (COND 
     ((< DTP 0)
      (PRINC (AR-1 DDT-ARTIFICIAL-POINTER-ARRAY (MINUS DTP))) (PRINC " ")
      (PRINC OFFSET))
     ((= DTP DTP-FIX)
      (PRINC OFFSET)
      )
     ((OR (= DTP DTP-SYMBOL) (= DTP DTP-NULL))
      (PRINC "<") (PRINC (Q-DATA-TYPES DTP)) (PRINC " ") (PRINC (%DAT PTR))
      (PRINC " ") (PRINC (%SDATTP (%P-LDB-OFFSET %%Q-POINTER PTR 0) DTP-ARRAY-POINTER))
      (PRINC ">")
      (COND ((NOT (ZEROP OFFSET))
	     (PRINC " ") (PRINC OFFSET)))
      )
     ((OR (= DTP DTP-SYMBOL-HEADER) (= DTP DTP-ARRAY-POINTER))
      (PRINC "<") (PRINC (Q-DATA-TYPES DTP)) (PRINC " ") (PRINC (%DAT PTR))
      (COND ((= (%P-LDB-OFFSET %%ARRAY-TYPE-FIELD PTR 0) ART-STRING)
	     (PRINC " ") (PRINC (%SDATTP PTR DTP-ARRAY-POINTER))))
      (PRINC ">")
      (COND ((NOT (ZEROP OFFSET))
	     (PRINC " ") (PRINC OFFSET)))
      )
     ((= DTP DTP-HEADER )
      (PRINC "<") (PRINC (Q-DATA-TYPES DTP)) (PRINC " ") (PRINC (%DAT PTR))
      (PRINC " ") (PRINC (NTH (%LDB %%HEADER-TYPE-FIELD PTR) Q-HEADER-TYPES))
      (PRINC " ")
      )
     ((= DTP DTP-U-ENTRY)
      (PRINC "<") (PRINC (Q-DATA-TYPES DTP)) (PRINC " ") (PRINC (%DAT PTR))
      (PRINC " ") (PRINC (MICRO-CODE-ENTRY-NAME-AREA PTR)) (PRINC ">")
      )
     ((= DTP DTP-LIST)
      (PRINC "<") (PRINC (Q-DATA-TYPES DTP)) (PRINC " ") (PRINC (%DAT PTR))
      (PRINC ">")
      (COND ((NOT (ZEROP OFFSET))
	     (PRINC " ") (PRINC OFFSET)))
      )
     ((OR (= DTP DTP-LOCATIVE) (= DTP DTP-CLOSURE))
      (PRINC "<") (PRINC (Q-DATA-TYPES DTP)) (PRINC " ") (PRINC (%DAT PTR))
      (PRINC ">")
      (COND ((NOT (ZEROP OFFSET))
	     (PRINC " ") (PRINC OFFSET)))
      )
     ((= DTP DTP-FEF-POINTER)
      (PRINC "<") (PRINC (Q-DATA-TYPES DTP)) (PRINC " ") (PRINC (%DAT PTR))
      (PRINC " ") (PRINC (%OFFSET-MEM-REF FEFHI-FCTN-NAME PTR)) (PRINC ">")
      (COND ((NOT (ZEROP OFFSET))
	     (PRINC " ") (PRINC OFFSET)))
      )
     ((= DTP DTP-ARRAY-HEADER)
      (PRINC "<") (PRINC (Q-DATA-TYPES DTP)) (PRINC " ") (PRINC (%DAT PTR))
      (PRINC " ") (PRINC (ARRAY-TYPES (%LDB %%ARRAY-TYPE-FIELD PTR))) (PRINC ">")
      )
     ((= DTP DTP-STACK-GROUP)
      (PRINC "<") (PRINC (Q-DATA-TYPES DTP)) (PRINC " ") (PRINC (%DAT PTR))
      (PRINC " ") (PRINC (ARRAY-LEADER (%SDATTP PTR DTP-ARRAY-POINTER) SG-NAME))
      (PRINC ">")
      (COND ((NOT (ZEROP OFFSET))
	     (PRINC " ") (PRINC OFFSET)))
      ) )
    (PRINC "   "))

; Top level.
; This is both the dispatcher and a "tty prescan."


(DEFUN DDT-TOP-LEVEL ()
    (PROG (CHAR SYNTAX COLUMN ALTMODE-COUNT TEM)
    START (STORE-ARRAY-LEADER DDT-READER-STRING 0 0)
          (SETQ ALTMODE-COUNT 0)
   GETCHR (SETQ CHAR (KBD-TYI))
          (AND (> ALTMODE-COUNT 2) (SETQ ALTMODE-COUNT 2))
          (SETQ COLUMN (+ (* 2 ALTMODE-COUNT)
			  (%LDB 1001 CHAR))	   ;The control bit.
		CHAR (LOGAND CHAR 377))
	  (COND ((< CHAR 40)
		 (FILL-ARRAY DDT-READER-STRING CHAR)
		 (TV-TYO DDT-PC-PPR CHAR)
		 (AND (= CHAR 33) (SETQ ALTMODE-COUNT (1+ ALTMODE-COUNT)))
		 (GO GETCHR)))
	  (SETQ SYNTAX (DDT-GET-SYNTAX CHAR COLUMN))
     DISP (COND ((NOT (FIXP SYNTAX))		   ;Then assume it is a function object.
		 (TV-TYO DDT-PC-PPR CHAR)
		 (SETQ DDT-SCANNER-POINTER 0)
		 (SETQ TEM (FUNCALL SYNTAX))
		 (COND ((EQ TEM T)		   ;If a command returns T, it wants more.
			(GO GETCHR))
		       ((NULL TEM)		   ;If NIL, it is done.
			(GO START))
		       (T (ERROR "Illegal returned value from DDT command" SYNTAX))))
		((PLUSP SYNTAX)
		 (SETQ SYNTAX (DDT-GET-SYNTAX SYNTAX COLUMN))
		 (GO DISP))
		((= SYNTAX DDT-SYNTAX-RUBOUT)		;Rubout.
		 (SETQ TEM (ARRAY-LEADER DDT-READER-STRING 0))
		 (AND (= (AR-1 DDT-READER-STRING TEM) 33)
		      (SETQ ALTMODE-COUNT (1- ALTMODE-COUNT)))
		 (TV-BACKSPACE DDT-PC-PPR)
		 (TV-CLEAR-CHAR DDT-PC-PPR)
		 (STORE-ARRAY-LEADER DDT-READER-STRING 0 (1- TEM))
		 (GO GETCHR))
		((= SYNTAX DDT-SYNTAX-CLEAR-SCREEN)	;Control-L and FORM.
		 (TV-CLEAR-PC-PPR DDT-PC-PPR)
		 (TV-STRING-OUT DDT-PC-PPR DDT-READER-STRING)
		 (GO GETCHR))
		((= SYNTAX DDT-SYNTAX-FLUSH-TYPEIN)	;Control-D and CLEAR.
		 (TV-TYO DDT-PC-PPR CHAR)
		 (TV-STRING-OUT DDT-PC-PPR " XXX? ")
		 (GO START))
		(T				    ;Alphanumeric, etc.
		 (FILL-ARRAY DDT-READER-STRING CHAR)
		 (TV-TYO DDT-PC-PPR CHAR)
		 (GO GETCHR))
		)))

;  Parser.
; This function gets the next token from the DDT-READER-STRING.
; (The pointer to where we are up to now is DDT-SCANNER-POINTER.)
; DDT-NEXT-TOKEN returns the next token in the line.

; It will return a string which you may NOT clobber; if you want to store
;    it somewhere or mung it, COPY it first.

; When it reaches the end, it stops and will from then on
;    return an empty string.

;******************************
; WHAT WILL THIS DO WITH SAIL CHARACTERS?

(DEFUN DDT-NEXT-TOKEN (&AUX FROM LIM)
	  (SETQ LIM (ARRAY-LEADER DDT-READER-STRING 0))

	  (DO ()				   ;PASS OVER INITIAL SPACES.
	      ((OR 
		(>= DDT-SCANNER-POINTER LIM)
		(NOT (= DDT-SYNTAX-BREAK
			(DDT-GET-SYNTAX
			 (AR-1 DDT-READER-STRING DDT-SCANNER-POINTER)
			 0)))))
	      (SETQ DDT-SCANNER-POINTER (1+ DDT-SCANNER-POINTER)))
	  (SETQ FROM DDT-SCANNER-POINTER)

	  (DO ()				    ;WAIT FOR A BREAK
	      ((OR
		(>= DDT-SCANNER-POINTER LIM) 
		(NOT (= DDT-SYNTAX-ALPHANUMERIC
			(DDT-GET-SYNTAX
			 (AR-1 DDT-READER-STRING DDT-SCANNER-POINTER)
			 0)))))
	      (SETQ DDT-SCANNER-POINTER (1+ DDT-SCANNER-POINTER)))
	  (DDT-SUBSTRING DDT-READER-STRING FROM DDT-SCANNER-POINTER))

(DEFUN DDT-GET-SYNTAX (CHAR COLUMN)
    (COND 
          ;((= CHAR 33) DDT-SYNTAX-BREAK)      ;???????
	  ((< CHAR 40) DDT-SYNTAX-ALPHANUMERIC)
	  (T (AR-2 DDT-COMMAND-DISPATCH-TABLE COLUMN (- CHAR 40)))))

(DEFUN DDT-SUBSTRING (STRING FROM TO &AUX LENGTH)
    (SETQ LENGTH (- TO FROM))
    (%OFFSET-MEM-STORE STRING DDT-READER-SUBSTRING 1)
    (%OFFSET-MEM-STORE LENGTH DDT-READER-SUBSTRING 2)
    (%OFFSET-MEM-STORE FROM DDT-READER-SUBSTRING 3)
    (%P-DPB-OFFSET 1 %%Q-USRC-BIT DDT-READER-SUBSTRING 1)
    DDT-READER-SUBSTRING)

; This gets the next token, and attempts to do good stuff to it:
; You can tell what it did by the datatype of the returned value:
;   (FIXNUM) If the token is a number, it will return a fixnum.
;   (QN)     Else if it is a "local symbol," it will return the associated QN.
;   (SYMBOL) Else if it is an interned symbol, it will return that symbol.
;   (STRING) Else it will return the original token.

(DEFUN DDT-EVAL-NEXT-TOKEN (&AUX TOKEN TEM LIM)
    (SETQ TOKEN (DDT-NEXT-TOKEN)
	  TEM 0
	  LIM (%ARRAY-ACTIVE-INDEX-LENGTH TOKEN))
    (COND ((= LIM 0)
	   TOKEN)
	  ((DO ((I 0 (1+ I))
		(CH))
	       ((= I LIM) T)
	     (SETQ CH (AR-1 TOKEN I))
	     (COND ((AND (>= CH ## 0) (<= CH ## 9))
		    (SETQ TEM (+ (* TEM DDT-INPUT-RADIX)
				 (- CH 60))))
		   (T (RETURN NIL))))
	   TEM)
	  ((SETQ TEM (ASSOC TOKEN DDT-LOCAL-SYMBOL-LIST))
	   (CDR TEM))
	  ((SYMBOLP (SETQ TEM (INTERN-SOFT TOKEN)))
	   TEM)
	  (T
	   TOKEN)))

;;; Evaluate a string typed before a DDT command.

; ****************************************
; THIS WILL NOT YET WIN ON <ARG>$<N>X OR WHATEVER.

; Simple for now, but a PROG for later on.
(DEFUN DDT-EVAL ()
  (PROG (TOKEN)
    (DDT-INITIALIZE-QN DDT-READIN-QN)
    (SETF (DDT-QN-DTP DDT-READIN-QN) DTP-FIX)
 L  (SETQ TOKEN (DDT-EVAL-NEXT-TOKEN))
    (COND ((NOT (STRINGP TOKEN))
	   (DDT-ADD-ON TOKEN))
	  ((STRING-EQUAL "+" TOKEN))
	  ((STRING-EQUAL "-" TOKEN)
	   (SETQ TOKEN (DDT-EVAL-NEXT-TOKEN))
	   (AND (STRINGP TOKEN) (DDT-BARF "Don't follow a '-' by a string" TOKEN))
	   (DDT-ADD-ON TOKEN (FUNCTION-EVAL '-)))
	  ((STRING-EQUAL "" TOKEN)   ; end of string
	   (RETURN DDT-READIN-QN)))
    (GO L)
    ))

;   This will accept any value returned by DDT-EVAL-NEXT-TOKEN except strings,
; and add it on to DDT-READIN-QN.
(DEFUN DDT-ADD-ON (Z &OPTIONAL
;		     (FUNCTION (FUNCTION-EVAL '+))
		     FUNCTION	                      ;***
		     )
    (OR FUNCTION (SETQ FUNCTION (FUNCTION-EVAL '+)))  ;***
    (COND ((FIXP Z)
	   (SETF (DDT-QN-OFFSET DDT-READIN-QN)
		 (FUNCALL FUNCTION Z (DDT-QN-OFFSET DDT-READIN-QN))))
	  ((SYMBOLP Z)
	   (OR (EQ (DDT-QN-DTP DDT-READIN-QN) DTP-FIX)
	       (DDT-BARF "Too many pointers."))
	   (SETF (DDT-QN-DTP DDT-READIN-QN) DTP-SYMBOL)
	   (SETF (DDT-QN-POINTER DDT-READIN-QN) (%SDATTP Z DTP-LOCATIVE)))
	  ((DDT-QN-P Z)
	   (COND ((EQ (DDT-QN-DTP DDT-READIN-QN) DTP-FIX)
		  (SETF (DDT-QN-DTP DDT-READIN-QN)
			(DDT-QN-DTP Z))
		  (SETF (DDT-QN-POINTER DDT-READIN-QN)
			(DDT-QN-POINTER Z))
		  (SETF (DDT-QN-OFFSET DDT-READIN-QN)
			(FUNCALL FUNCTION (DDT-QN-OFFSET DDT-READIN-QN)
				          (DDT-QN-OFFSET Z))))
		 ((EQ (DDT-QN-DTP Z) DTP-FIX)
		  (SETF (DDT-QN-OFFSET DDT-READIN-QN)
			(FUNCALL FUNCTION (DDT-QN-OFFSET DDT-READIN-QN)
				          (DDT-QN-OFFSET Z))))
		 (T (DDT-BARF "Too many pointers."))))
	  (T
	   (ERROR "Wrong type argument -- DDT-ADD-ON" Z))))

;;; Examine and deposit.

(DEFUN DDT-EXAMINE (LOC INTO &AUX DTP PTR OFFSET)
    (SETQ DTP (DDT-QN-DTP LOC)
	  PTR (DDT-QN-POINTER LOC)
	  OFFSET (DDT-QN-OFFSET LOC))
    (COND ((OR
	    (AND (OR (= DTP DTP-ARRAY-POINTER)
		     (= DTP DTP-SYMBOL-HEADER))
		 (<= OFFSET
		     (+ (%P-LDB-OFFSET %%ARRAY-LONG-LENGTH-FLAG PTR 0)
			(%P-LDB-OFFSET %%ARRAY-NUMBER-DIMENSIONS PTR 0))
		     )
		 (>= OFFSET
		     (COND ((= 1 (%P-LDB-OFFSET %%ARRAY-LEADER-BIT PTR 0))
			    (MINUS (+ 2 (%P-LDB-OFFSET %ARRAY-LEADER-LENGTH PTR 1))))
			   (T 0))
		     ))
	    (= DTP DTP-LOCATIVE)
	    (= DTP DTP-LIST)
	    (AND (= DTP DTP-CLOSURE)
		 (>= OFFSET 0)
		 (<= OFFSET (LENGTH (%SDATTP PTR DTP-CLOSURE))))
	    (AND (= DTP DTP-FEF-POINTER)
		 (>= OFFSET 0)
		 (<= OFFSET FEF-HEADER-LENGTH))
	    (= DTP DTP-STACK-GROUP)
	    (AND (= DTP DTP-SYMBOL)
		 (>= OFFSET 0)
		 (<= OFFSET 4))
	       )
	   (SETF (DDT-QN-DTP INTO) (%P-LDB-OFFSET %%Q-DATA-TYPE PTR OFFSET))
	   (SETF (DDT-QN-POINTER INTO) (%P-LDB-OFFSET %%Q-POINTER PTR OFFSET))
	   (SETF (DDT-QN-OFFSET INTO) 0))
	  (T (DDT-BARF "  ??")))		;RETURN A DTP WHICH PRINTS OUT THIS WAY??
    INTO)

(DEFUN DDT-DEPOSIT (LOC QN &AUX DTP PTR OFFSET)
    (SETQ DTP (DDT-QN-DTP LOC)
	  PTR (DDT-QN-POINTER LOC)
	  OFFSET (DDT-QN-OFFSET LOC))
    (COND ((OR (= DTP DTP-ARRAY-POINTER)
	       (= DTP DTP-SYMBOL-HEADER)
	       (= DTP DTP-LOCATIVE)
	       (= DTP DTP-LIST)
	       (= DTP DTP-CLOSURE)
	       (= DTP DTP-FEF-POINTER)
	       (= DTP DTP-STACK-GROUP)
	       (= DTP DTP-SYMBOL)
	       )
	   (%P-DPB-OFFSET (DDT-QN-DTP QN) %%Q-DATA-TYPE PTR OFFSET)
	   (%P-DPB-OFFSET (DDT-QN-POINTER QN) %%Q-POINTER PTR OFFSET))
	  (T (DDT-BARF "  ??")))
    QN)

;;; DDT commands.
       
(DEFMACRO DDT-NO-ARG-P ()
    '(ZEROP (ARRAY-LEADER DDT-READER-STRING 0)))

(DEFUN DDT-CMD-UNDERSCORE (&AUX ARG)
    (SETQ ARG (COND ((DDT-NO-ARG-P) DDT-ALT-Q)
		    (T (DDT-EVAL))))
    (DDT-STANDARD-TYPE-OUT ARG)
    NIL)

(DEFUN DDT-CMD-BACKSLASH (&AUX ARG)
     (COND ((DDT-NO-ARG-P)
	    (SETQ ARG DDT-ALT-Q))
	   (T
	    (SETQ ARG (DDT-EVAL))
	    (AND DDT-OPEN-P
		 (DDT-DEPOSIT DDT-OPEN-QN ARG))))
     (DDT-SET-QN DDT-OPEN-QN ARG)
     (SETQ DDT-OPEN-P T)
     (DDT-TYPE-OUT (DDT-EXAMINE DDT-OPEN-QN DDT-ALT-Q))
     NIL)

(DEFUN DDT-CMD-SLASH (&AUX ARG)
    (SETQ ARG (COND ((DDT-NO-ARG-P) DDT-ALT-Q)
		    (T (DDT-EVAL))))
    (DDT-SET-POINT ARG)
    (DDT-SET-QN DDT-OPEN-QN ARG)
    (SETQ DDT-OPEN-P T)
    (DDT-TYPE-OUT (DDT-EXAMINE DDT-OPEN-QN DDT-ALT-Q))
    NIL)

(DEFUN DDT-CMD-RETURN ()
    (COND ((AND (NOT (DDT-NO-ARG-P))
		DDT-OPEN-P)
	   (DDT-DEPOSIT DDT-OPEN-QN (DDT-EVAL))))
    (SETQ DDT-OPEN-P NIL)
    (DDT-RESET-TEMPORARY-MODE)
    NIL)

(DEFUN DDT-CMD-LINE ()
    (COND ((AND (NOT (DDT-NO-ARG-P))
		DDT-OPEN-P)
	   (DDT-DEPOSIT DDT-OPEN-QN (DDT-EVAL))))
    (SETF (DDT-QN-OFFSET DDT-POINT)
	  (1+ (DDT-QN-OFFSET DDT-POINT)))
    (DDT-SET-QN DDT-OPEN-QN DDT-POINT)
    (SETQ DDT-OPEN-P T)
    (TV-CRLF DDT-PC-PPR)
    (DDT-TYPE-OUT DDT-OPEN-QN)
    (TV-STRING-OUT DDT-PC-PPR "//  ")
    (DDT-TYPE-OUT (DDT-EXAMINE DDT-OPEN-QN DDT-ALT-Q))
    NIL)

(DEFUN DDT-CMD-UPARROW ()
    (COND ((AND (NOT (DDT-NO-ARG-P))
		DDT-OPEN-P)
	   (DDT-DEPOSIT DDT-OPEN-QN (DDT-EVAL))))
    (SETF (DDT-QN-OFFSET DDT-POINT)
	  (1- (DDT-QN-OFFSET DDT-POINT)))
    (DDT-SET-QN DDT-OPEN-QN DDT-POINT)
    (SETQ DDT-OPEN-P T)
    (TV-CRLF DDT-PC-PPR)
    (DDT-TYPE-OUT DDT-OPEN-QN)
    (TV-STRING-OUT DDT-PC-PPR "//  ")
    (DDT-TYPE-OUT (DDT-EXAMINE DDT-OPEN-QN DDT-ALT-Q))
    NIL)

