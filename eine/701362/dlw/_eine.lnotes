
Comment: EAK@MIT-AI 07/21/78 04:54:32
Comment: *** END OF ORIGINAL HEADER ***
Date: 07/21/78 04:54:32
From: EAK@MIT-AI

You ought to hack up a version of the SPELL program for EINE.
One mode might be somewhat like the current SPELL program,
i.e. run through a buffer/file and find errors.  Another would
be spell a given word (e.g. the one I just typed and looks
"wrong").  Another would be to feep at any word I type which
it doesn't know.
DLW@MIT-AI 06/28/78 21:20:09
To: MMCM at MIT-AI, (FILE [DLW;.EINE LNOTES]) at MIT-AI
The list of minor modes to carry along seems reasonable.
It has the "problem" that the new minor modes depend on the ones
of the buffer you are coming from, which may or may not be good.
Two alternatives, in order of increasing flexibility (good) and
increasing number of user command needed (bad) are
1) Have a global list of minor modes for new buffers.
Need commands to add to, subtrace from, and look at this list.
2) Have such a list for each major mode, thus allowing the user
to say that he wants autofilling for all Text mode buffers.
Need the same commands as above only hairier, also mode
switching would have to fool around with this as well.

For the time being maybe just leave it as it is.


DLW@MIT-AI 06/23/78 17:17:44
To: MOON at MIT-AI, MMCM at MIT-AI, DLW at MIT-AI
Yes, I like the idea of ED-BUFFER-KILL-EDGE-SMARTS.  One problem with it
for me is that I tend to use word commands no matter what I am editing;
I know them so well that I don't think of them as word commands anymore,
but rather as "move past alphabetics".  Thus I constantly use them in Lisp
code and so forth.  Now, I don't exactly see any problem;
but I anticipate that I may find the thing inserting apces on me.
I would like to hxve this feature conditional on a flag,
and also make it possible to set things up so thxt it only happens in Text
mode or something.  (BTW, Dave, as far as I can tell the screws that
were in the original Text mode are gone, and it is safe for people
now.)

This also means that "TECO buffers" are going to have to have leaders;
making them simple arrays of strings wouldn't provide a place for
this information.


I agree about the mouse; the existing kludge loses and without
sometting to replace it the mouse would be 90% less usable.

Any plans to do this in EMACS?
    
MOON@MIT-MC 06/23/78 15:31:22 Re: EINE
To: dlw at MIT-AI, mmcm at MIT-AI

The following is only hand-waving so far, but it should be possible
to pin it down without too much trouble.  I'd like to add a field to
buffers called ED-BUFFER-KILL-EDGE-SMARTS, which is usually NIL.  In a normal
buffer it means that the currently-marked region was created by a word
or other specific-quantity command, and if you kill it smarts should occur.
In a buffer on the kill-ring, it means the kill happened with this flag set
or was done by a specific-quantity command, so if you yank it smarts should
occur.  The basic idea of the smarts is that words (for example) are
supposed to be surrounded by delimiters always; killing should delete
extraneous spaces and yanking should insert spaces if necessary.  Probably
the smarts field can be any symbol, to allow for future expansion to
yet more hair!  The idea is that if you specificly mark a region by
using ^@, it does what you said.  But if you use m-D or ^QDS or m-H c-W,
it is free to mess around with the spaces, tabs, and crlfs (but not
printing delimiters such as commas) to prettify things.  This will
be especially important for mouse commands, I suspect.  Note that editing
an existing region with the mouse or by moving point around must turn
off the smartness.
    H@MIT-AI 06/09/78 21:52:08 Re: EINE underlining, when (and if) you want it.
I don't care much for the underlining, but mostly
because it is ugly and distracting.

Other options of underlining that might be prettier:

	Display a little carat at the mark position.
	Display little under-arrows that point towards
	  the enclosed text, but are short enough to
	  be unobtrusive.
	Display halftone shaded underline. (Dotted)
	Display halftone background behind marked text.

Yes, yes, I realize that some of the above really need
a higher resolution display!  It is coming. Meanwhile
something could be tried with the current display.

  
DLW@MIT-AI 05/31/78 23:46:23 Re: c-Y turning off the region
To: MOON at MIT-MC
CC: DLW at MIT-AI, MMCM at MIT-AI
    MOON@MIT-MC 05/30/78 14:53:50 Re: c-Y turning off the region
    To: dlw at MIT-AI
    The big problem with this is you can no longer undo the c-Y with
    a c-W, you need a c-X c-X first.  Perhaps the region commands,
    when the region is not on, instead of giving an error should turn the
    region on, display it, and ask you if you want to <operation> this region.
Well, this still sounds a little inconvenient.  Hau do you like
this alternate proposal: Meta-Y and Control-W, by divine fiat,
work even it there is no region ONLY IF the last-command-type was
YANK (which would be set by Control-Y and Meta-Y)?  The theory
is that you know what it is you yanked and don't need to be told.

Another alternate theory is that Control-Y should turn on the region,
but somehow it should get turned off after the next command, unless
the next command is Meta-Y.
    
MOON@MIT-MC 06/01/78 16:42:48 Re: c-Y turning off the region
To: DLW at MIT-AI
Well, I guess c-W and m-Y knowing about last command type of yank
is probably the right kludge.
  
TK@MIT-AI 05/30/78 01:22:58
To: (BUG LISPM) at MIT-AI
Blue sky, editors, and menus

Nice features for someday:

editor interface to package structure, menu selection of function to edit from list
	of functions in this package, or selection of sub-packages for new menu

editor has a menu listing all functions this function calls, selecting one brings this
	function into the editing window
	(this may not need to be a menu, could just select the text string for the
	function name, but I think a menu would be more flavourful.)

editor has a menu listing all functions that call this function, ditto
	perhaps this has some feature for keeping track of which functions
	have been examined for the common case of modifying all calls to a
	(redefined) function

editor has a ring buffer of recently edited functions, a la ddt <alt><return>
	mechanism for returning to the old ones

EH stuff:
	window comes up showing backtrace, selecting function shows definition, bound
	variable names come up as a menu
	selecting variable name shows binding of the variable

Also it is a bit of a pain to put (SETQ ED=MARK-STAYS T) into all of
these functions, so maybe this bit couls be in the macro somewhere, and
put a property on the name of the function which the command loop
would look at.  For functions which aren't gotten to via ED-COM- names,
we can just let them (SETQ ED-MARK-STAYS T) like they do now.
 
DLW@MIT-AI 05/30/78 15:03:32
To: MMCM at MIT-AI, DLW at MIT-AI
I see that ED-BACKWARD-DEFUN-BP seems to be different from the existing
ED-BACKWARD-LIST-BP type commands, in two ways:
2) It doesn't make a copy of the BP itself, so the caller has to.
   I guess the right thing would be for them all to take an argument as
   to whether to copy or not (we could have it default to "do copy" so that
   existing code would require fewer changes, but that's a random point).

MOON@MIT-MC 05/30/78 14:53:50 Re: c-Y turning off the region
To: dlw at MIT-AI
...
It's related to what happens if you put the cursor at the end of a
line, and to continuation lines.  Perhaps there should always be
an extra "space" at the end of each line, whose purpose is for a place
to put the cursor when it is at the end and a place to put the underline
when the newline is in the region.  This implies doing continuation one
character earlier than now (best done by moving the pc-ppr-right-limit
in I guess.)
