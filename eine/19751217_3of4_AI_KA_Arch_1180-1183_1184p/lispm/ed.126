;CONS TEXT FORMAT FOR EDITOR, DISPLAYING, ETC
;  THE EDITOR OPERATES ON UNITS CALLED "BUFFERS"
;	A BUFFER IS A SINGLE DIMENSIONAL Q ARRAY, EACH OF WHOSE
;	  MEMBERS POINTS TO A "LINE" (OR NIL IN THE CASE OF A NULL LINE).
; 	  ADDITIONAL INFORMATION 
;	  PERTAINING TO THE BUFFER IS STORED IN THE LEADER OF THE ARRAY.
;
;       A "LINE" IS A SINGLE DIMENSIONAL (STRING) BYTE ARRAY.  ADDITIONAL INFORMATION
;	  PERTAINING TO THE LINE IS STORED IN THE LEADER OF THE ARRAY.
;	  LINES ARE SEPARATED FROM EACH OTHER BY CARRIDGE-RETURNS. (IN EDITING-LISP MODE
;	  HOWEVER, SLASHIFIED CHARACTERS, INCLUDING CARRIDGE-RETURNS, DO NOT
;	  SEPARATE LINES.  LINES MAY BE ARBITRARILY LONG (OR ACTUALALLY 
;	  (1- ED-INFINITY) MAXIMUM).
;
;       A "DISPLAY WINDOW" IS A SINGLE DIMENSIONAL Q ARRAY.  IT SPECIFIES
;         AN AREA OF THE SCREEN, AND RECORDS FOR EACH PHYSICAL LINE 
;         WHAT INCARNATION OF WHAT LINE IS CURRENTLY BEING DISPLAYED ON THAT LINE.
;	  THE ARRAY ELEMENTS ARE CONSIDERED TO BE GROUPS OF ED-DISPLAY-WINDOW-STEP.
;	  THE FIRST OF EACH GROUP 
;	  HOLDS THE IDENTITY NUMBER AND THE SECOND THE INCARNATION NUMBER.
;	  AN INCARNATION NUMBER OF -1 MEANS THAT THIS PHYSICAL LINE IS
;	  TAKEN UP WITH THE CONTINUATION OF THE PREVIOUS LOGICAL LINE (THE IDENTITY
;	  NUMBERS OF THIS LINE AND THE PREVIOUS ONE SHOULD MATCH IN THIS CASE).
;
;       A "BUFFER POINTER" IS A 2 LIST (<POINTER TO BUFFER>, <INDEX>).
;	  INTERNALLY TO THE EDITOR, A BUFFER POINTER MAY ALSO BE JUST A FIXNUM <INDEX>,
;	  IN WHICH CASE THE BUFFER IS POINTED TO BY ED-OPEN-BUFFER.
;         <INDEX>, WHICH MUST BE AN DIVISIBLE BY ED-BFA-STEP, IS TAKEN TO BE AN INDEX
;	  OF THE BUFFER POINTER ARRAY (BFA)
;	  WHICH IS IN TURN ASSOCIATED WITH THE BUFFER.  THE BUFFER POINTER
;	  ARRAY IS A ONE DIMENSIONAL ARRAY WHOSE ELEMENTS ARE CONSIDERED GROUPS OF
;	  ED-BFA-STEP.
;	  (BFA <INDEX>) ACCESSES THE LINE # AT WHICH THE BUFFER 
;	  POINTER POINTS, AND (BFA (1+ <INDEX>) THE CHARACTER #.
;	  BY CONVENTION, THE INDEX 0,1 PAIR IS "THE POINTER" INTO THE ENTIRE
;	  BUFFER (AS SEEN BY THE USER). 
;	    WHEN A BUFFER POINTER IS CHANGED, THE ENTRIES IN THE BFA TABLE ARE
;	  DIRECTLY ALTERED.  THUS, IN ORDER TO SAVE A BUFFER POINTER ONE MUST
;	  COPY INTO ANOTHER BUFFER POINTER, NOT MERELY MAKE ANOTHER COPY OF THE
;	  POINTER TO THE FIRST ONE.
;	    A BUFFER POINTER IS GENERALLY CONSIDERED TO "NAME" AN INDIVIDUAL CHARACTER
;	  IN THE BUFFER. THE LINE NUMBER COORDINATE IS STRAIGHTFORWARD.  FOR THE
;	  CHARACTER NUMBER COORDINATE, HOWEVER, A FEW SPECIAL CONVENTIONS APPLY.
;	  CHARACTER NUMBERS OF 0 TO (1- ED-INFINITY) ADDRESS 
;	  THE N TH (STARTING WITH 0 TH)
;	  CHARACTER IN THE LINE.  THIS CAN BE REALIZED BY SIMPLY 
;	  (FUNCALL <LINE-POINTER> N). A CHARACTER NUMBER OF -1, HOWEVER, IS CONSIDERED
;	  TO POINT BEFORE THE BEGINNING OF THE LINE, AND A CHARACTER NUMBER OF
;	  ED-INFINITY IS CONSIDERED TO POINT AFTER THE END OF THE LINE. THUS,
;	  <N , -1> IS THE SAME POINTER AS <N-1, ED-INFINITY> WHICH IS THE SAME POINTER
;	  AS <N-1 , M> WHERE M IS THE NUMBER OF CHARACTERS IN LINE N-1. THESE
;	  CONVENTIONS ARE NOT INTENDED TO REPRESENT A USER LEVEL FEATURE, BUT
;	  ARE MAINLY FOR THE CONVIENENCE OF INTERNAL EDITOR ROUTINES, AND ARE NOT
;	  NECESSARILY SUPPORTED AT INTERNAL POINTS IN THE EDITOR. NOTE ALSO THAT
;	  NO ALLOWANCE IS MADE FOR THE CARRIDGE RETURN WHICH SEPARATES THE LINES,
;	  ITSELF.
;	    AN ATTEMPT IS MADE TO CAUSE
;         BUFFER POINTERS TO POINT TO A "CONSTANT" PLACE IN THE TEXT
;         DESPITE INSERTIONS OR DELETIONS THAT MAY OCCUR. 

;  GENERAL:  EACH LINE IS PERMITTED TO BE POINTED TO BY ONLY BY A SINGLE
;    POINTER.  THUS TO COPY A LINE, ONE MUST DUPLICATE IT AND TO COPY A BUFFER
;    ONE MUST DUPLICATE IT AND ALL ITS LINES. 
;	     THE STORAGE LENGTH OF A LINE OR BUFFER IS GIVEN IN THE NORMAL MANNER
;    FOR ARRAYS BY THE %%ARRAY-STORAGE-LENGTH FIELD OF THE ARRAY HEADER.  THE AMOUNT
;    OF THAT STORAGE CURRENTLY IN USE IS GIVEN BY LEADER ELEMENT 0.
;    THUS, THE FILL-ARRAY FUNCTION CAN BE USED TO ADD CHARACTERS TO A LINE OR
;    LINES TO A BUFFER.  IF IT SHOULD FAIL, (IE NO ROOM TO ADD AN ADDITIONAL ELEMENT),
;    THE LINE OR BUFFER MUST BE RECOPIED TO MAKE ADDITIONAL ROOM.
;	     IN ORDER TO FACILITATE UPDATING THE DISPLAY, A NUMBER OF FEATURES
;    EXIST TO ENABLE THE SYSTEM TO KEEP TRACK OF HOW MUCH DISPLAY ROOM A LINE
;    TAKES AND WHETHER IT HAS BEEN CHANGED SINCE THE DISPLAY WAS LAST UPDATED.
;	     EACH LINE IN A BUFFER, AT THE TIME OF ITS CREATION, IS ASSIGNNED A
;    UNIQUE NUMBER.  THIS NUMBER IS OBTAINNED BY INCREMENTING AN ASCENDING
;    COUNT ASSOCIATED WITH THE BUFFER.  EACH LINE ALSO HAS AN "INCARNATION"
;    NUMBER, WHICH IS INCREMENTED EACH TIME THE LINE IS CHANGED.  
;	     EACH LINE HAS A VARIABLE WHICH SAYS HOW MANY PHYSICAL DISPLAY LINES ARE 
;    REQUIRED TO DISPLAY THIS LINE.  IF THIS VARIABLE IS -1, THIS NUMBER HAS
;    NOT BEEN COMPUTED YET FOR THIS LINE.  THE VALUE OF THE VARIABLE IS DEPENDANT
;    ON THE ASSUMED DISPLAY WINDOW WIDTH WHICH IS CONTAINED IN INFORMATION ASSOCIATED
;    WITH THE BUFFER.  IF THE INFORMATION ASSOCIATED WITH THE BUFFER CHANGES,
;    ONE MUST SCAN THRU THE BUFFER AND INVALIDATE THE # PHYSICAL LINES VARIABLE
;    FOR ALL THE LINES IN THE BUFFER.
;	    EACH LINE ALSO HAS VARIABLES ASSOCIATED WITH THE PRESENCE OF 
;    OPEN AND/OR CLOSE PARENS ON THE LINE. EACH VARIABLE MAY HAVE THE SPECIAL VALUE
;    ED-INFINITY TO INDICATE THE ACTUAL VALUE HAS NOT AS YET BEEN COMPUTED.
;		THE NET NUMBER OF (OPENS-CLOSES) 
;		THE MAX "CLOSE DEPTH" SCANNING FROM THE LEFT. (IE IF YOU ARE N OPENS
;		   DEEP IN AN S-EXPRESSION WHEN STARTING THE LINE, THAT S-EXPRESSION
;		   WILL BE CLOSED ON THIS LINE. IN YOU ARE >N DEEP, IT WONT BE.
;		THE MAX "OPEN DEPTH" SCANNING FROM THE RIGHT.
;
; BASIC OPERATION OF THE EDITOR.
;   ALL EDITING OPERATIONS A CONSIDERED TO BE COMPOSED OF MICRO-OPERATIONS OF
; WHICH THERE ARE TWO TYPES: INTRA-LINE EDITING OPERATIONS AND INTER-LINE
; EDITING OPERATIONS.
;   INTRA-LINE OPERATIONS ARE ALWAYS DONE ON A SINGLE LINE (THE "OPEN" LINE,
; SIMILIAR TO THE OPEN REGISTER IN DDT).  THE LINE IS NOT REALLY OPENED, HOWEVER,
; UNTIL IT IS DETERMINED THAT SOME EDITING ON THE LINE IS GOING TO WANT TO HAPPEN.
;    OPENING A LINE CONSISTS OF COPYING IT (WITH A NEW INCARNATION NUMBER).
; (IF THE LINE WAS PREVIOUSLY NULL, A NEW LINE BLOCK IS CREATED.)
; A POINTER TO THE NEW INCARNATION OF THE LINE IS STORED BACK INTO THE BUFFER,
; BUT A POINTER TO THE OLD COPY IS KEPT IN ED-BUFFER-OLD-COPY-OPEN-LINE.
; THIS IS DONE FOR THE CONVENIENCE OF THE DISPLAY ROUTINES.
; ANY DESIRED CHANGES MAY THEN BE MADE. IN THIS
; PROCESS, HOWEVER, A RECORD IS KEPT OF THE LOCATIONS OF THESE CHANGES
; IN THE FORM OF A LIST OF (<OPERATION>, <LOCATION>, <NUMBER>).  <OPERATION> CAN BE
; INSERT OR DELETE, <LOCATION> IS THE LOCATION WITHIN THE LINE AT WHICH THE
; OPERATION OCCURRED, AND <NUMBER> IS THE NUMBER OF CHARACTERS INSERTED OR DELETED.
;    CLOSING A LINE IS DONE WHEN IT IS DESIRED TO OPEN SOME OTHER LINE, TO DO
; AN INTER-LINE EDITING OPERATION OR TO FILE
; OUTPUT. IT IS NOT NECESSARY TO CLOSE THE LINE TO UPDATE THE DISPLAY.
; IN ADDITION TO CLOBBERING BACK THE POINTER TO THE LINE IN THE BUFFER,
; CLOSING THE LINE MUST RELOCATE ANY BUFFER POINTERS THAT MAY HAVE BEEN
; EFFECTED AND MUST MAKE APPROPRIATE ENTIRES ON THE HISTORY LIST (CONSISTING
; OF BOTH THE OLD LINE AND OLD BUFFER POINTER VALUES.
;  INTER-LINE EDITING OPERATIONS CONSIST SOLELY OF SHUFFLING THE POINTERS TO LINES
; IN THE LINE-POINTING PART OF THE BUFFER.  TO DELETE A LINE, FOR EXAMPLE,
; ALL POINTERS TO LINES ABOVE THAT LINE MUST BE "BLT ED" DOWN ONE.
; AGAIN, APPROPRIATE BUFFER-POINTER
; RELOCATIONS AND HISTORY LIST UPDATING MUST BE DONE. INTER-LINE EDITING CAN
; ONLY BE DONE WHEN THERE IS NO LINE OPEN FOR INTRA-LINE EDITING.
;
;	IN A SIMILAR MANNER TO THE OPEN LINE, AN OPEN BUFFER IS DEFINED.
; ALL EDITING OPERATIONS ARE PERFORMED ON THE OPEN BUFFER.  OPENING A BUFFER
; CONSISTS OF TRANSFERRING INFORMATION OUT OF ITS ARRAY LEADER TO A SET
; OF SPECIAL VARIABLES WHICH ARE REFERENCED BY THE EDITING FUNCTIONS,
; AND CLOSING IT CONSISTS MERELY OF TRANSFERRING THEM BACK.

;OVERALL EDITING OPERATION.  
;  EDITING LISP:  A BUFFER IS LOGICALLY ASSOCIATED WITH EACH FUNCTION.
;	THIS BUFFER MAY BE STORED ON THE PROPERTY LIST OF THE FUNCTION OR
;    CREATED WHEN NEEDED BY GRINDEF OR READING IT IN FROM A FILE. WHEN
;    IT IS DESIRED TO "QUIT" EDITING THE FUNCTION, THE CONTENTS OF THE
;    BUFFER ARE FED TO READ.  THE RESULTING S-EXPRESSION MAY IF DESIRED
;    SIMPLY BE STORED BACK IN THE FUNCTION CELL, ETC.  ALTERNATIVELY, AN
;    "INTEGRATE" MAY BE ATTEMPTED.  AN INTEGRATE IS A SEMI-HEURISTIC OPERATION
;    WHICH IS OF INTEREST ONLY IF ONE IS IN THE MIDDLE OF AN ON-GOING
;    COMPUTATION WHICH ONE WISHES TO CONTINUE USING THE NEWLY EDITED DATA
;    TO REPLACE THE OLD.  SINCE ARBITRARY DECISIONS CAN BE INVOLVED THIS GENERAL
;    PROCESS, THE MAIN EMPHASIS IS TO GIVE THE USER WARNING IF THERE EXIST
;    WITHIN THE SYSTEM (MORE ACCURATELY, ON THE PUSH DOWN LIST) POINTERS
;    TO SECTIONS OF CODE WHICH HAVE BEEN DELETED, OR DO NOT CORRESPOND IN
;    AN OBVIOUS MANNER TO SECTIONS IN THE NEW COPY.  IF ANY POINTERS ARE FOUND
;    TO SECTIONS OF THE OLD THING WHICH DO CORRESPOND, THEY ARE RELOCATED.
;    IF A WARNING MESSAGE IS TYPED, IT IS EXPECTED THAT THE USER WILL NORMALLY
;    QUIT AND START THE WHOLE THING OVER, SINCE IT IS TOO MUCH PAIN TO FIGURE
;    OUT EXACTLY WHAT IS GOING ON (HE CAN TRY IF HE WANTS, THOUGH).
;	IT IS BELIEVED THAT THIS APPROACH IS SUPERIOR, IN USER CONFIDENCE AT LEAST,
;    TO THE APPROACH WHERE THE EDITOR DIRECTLY EDITS THE ACTUAL S-EXPRESSION,
;    THEN SIMPLY PROCEEDS, SINCE WITH THAT APPROACH THE USER RECEIVES NO WARNING
;    IF HE IS BEING SCREWED. FURTHERMORE, AN EDITOR EDITING THE ACTUAL S-EXPRESSION
;    DOES NOT LEND ITSELF CONVIENENTLY TO EFFICIENT USE OF THE DISPLAY.
;  EDITING GENERAL TEXT: THE BUFFER CAN BE HUNG OFF ANYWHERE CONVIENENT, ETC.
;    EXTREMELY LARGE BUFFERS CAN CAUSE SEMI-SERIOUS OVERHEADS ON INTER-LINE
;    EDITING OPERATIONS NEAR THE BEGINNING OF THE BUFFER, BUT THIS SHOULD NOT
;    BE A SERIOUS PROBLEM (I DONT THINK).

;  "STRUCTURE" WITHIN A BUFFER.
;   CERTAIN STRUCTURE IS INHERITLY PROVIDED BY THE EDITING SYSTEM ITSELF
;   AT LEVELS BOTH ABOVE AN BELOW THE UNIT OF THE BUFFER.  AN EXAMPLE IS THE
;   SYSTEM OF MULTIPLE BUFFERS WITH A BUFFER CORRESPONDING TO A FUNCTION OR
;   CHAPTER.  ANOTHER IS THE DIVISION INTO LINES, ETC.
;   IN MANY CASES, HOWEVER, IT IS HIGHLY DESIRABLE TO PROVIDE ADDITIONAL STRUCTURE
;   WHICH MAY BE DATA-TYPE SPECIFIC IN SOME CASES.  FOR EXAMPLE, ONE MAY HAVE
;   A COMMAND TO JUMP DIRECTLY TO A GIVEN TAG IN A PROG, OR TO A GIVEN CHAPTER,
;   ETC.  ASSUMING ONE WISHES TO PROVIDE SUCH COMMANDS, IN SOME CASES IT IS LARGELY 
;   AN IMPLEMENTATION DECISION WHETHER A DATA BASE SHOULD BE MAINTAINED AND
;   UPDATED OR WHETHER THE SYSTEM SHOULD LOCATE THE DESIRED POINT
;   BY A SPECIALIZED SEARCH ON THE TEXT STRING EACH TIME REQUESTED.
;   THE DATA-BASE IS CLEARLY REQUIRED IF ONE WISHES TO BE ABLE TO PROCEED TO
;   ARBITRARY POINTS IN THE TEXT WHICH ARE NOT NECESSARILY LOCALLY DISTINGUISHED
;   IN A MANNER THEY CAN BE SEARCHED FOR. FOR EXAMPLE, IF ALL TAGS END WITH A
;   COLON, THEY ARE LOCALLY DISTINGUISHED. BUT ALL REFERENCES TO "INVISIBLE DATA
;   TYPES" MAY NOT BE UNIQUELY LOCALLY DISTINGUISHED.  TO PROVIDE AN EFFICIENT
;   MEANS OF UPDATING THESE DATA BASES 
;   A LIST OF "STRUCTURE TABLES" MAY BE ASSOCIATED WITH A BUFFER.
;   THESE CONTAIN INFORMATION SIMILIAR TO THE BUFFER POINTER ARRAY, BUT WITH
;   THE FOLLOWING DIFFERENCES:
;      1) THE BUFFER POINTERS ARE REFERENCED BY A "KEY", WHICH IS AN ARBITRARY
;	    LISP-MACHINE Q.  THUS, THEY ARE CONSIDERED IN TRIPLES INSTEAD OF PAIRS.
;	    THE THIRD MEMBER OF THE TRIPLE HOLDS THE KEY.
;      2) THE ENTRIES ARE LOG SORTED BY LINE NUMBER FOR FAST LOOK-UP AND UPDATING.
;   A STRUCTURE TABLE MAY SPECIFY THAT IT IS REALLY A FUNCTION (PRESUMABLY
;   SEARCHING FUNCTION), IN WHICH CASE, THAT ENTRY IS IGNORED WHEN UPDATING
;   BUFFER POINTERS, BUT PRESUMABLY MAY BE ACESSED WHEN ATTEMPTING TO RETRIEVE
;   A VALUE ASSOCIATED WITH A KEY BY THE STRUCTURE.


;DISPLAY UPDATING:
;  THERE ARE FIVE BASIC "SORTS" OF DISPLAY UPDATE THAT CAN OCCUR.
;    THESE ARE 1) CLEAN-WIPE 2) LINE-REDISPLAY 3) PARTIAL-LINE-REDISPLAY.
;    4) CHARACTER-ADD AND 5) CURSOR-POSITION.
;    UNDER APPROPRIATE CONDITIONS, AN ATTEMPT TO DO A (4) CAN RESULT IN A
;   (3) CAN RESULT IN A (2),
;    WHICH CAN RESULT IN A (1), BUT THIS IS NOT THE COMMON CASE.
;  DISPLAY UPDATE TYPES 1 THRU 4 TAKE AS ARG A LINE NUMBER <LINE>, ON WHICH THE
;    "CURSOR" IS ASSUMED TO RESIDE FOR PURPOSES OF DISPLAY POSITIONING.
;    TWO VARIABLES ASSOCIATED WITH THE DISPLAY WINDOW 
;    CONTROL HOW CLOSE THIS LINE WILL BE ALLOWED TO "WANDER"
;    TO THE EDGES OF THE SCREEN BEFORE A CLEAN-WIPE IS INITIATED.
;    THESE ARE ED-WINDOW-MIN-CURSORPOS AND ED-WINDOW-MAX-CURSORPOS.
;    IF <LINE> WOULD BE STARTED ON A PHYSICAL LINE NUMBER OUT OF THE RANGE
;    THESE VARIABLES DEFINE, A CLEAN-WIPE HAPPENS.  IF A CLEAN-WIPE DOES HAPPEN
;    <LINE> GETS POSITIONED ON THE SCREEN UNDER THE CONTROL OF TWO MORE
;    VARIABLES, ED-WINDOW-MIN-RESET-CURSORPOS AND ED-WINDOW-MAX-RESET-CURSORPOS.
;    IF LINE ATTEMPTED TO BE DISPLAYED ON A LINE  LESS THAN MIN-CURSORPOS,
;    IT WILL BE REPOSITIONED TO PHYSICAL LINE MIN-RESET-CURSORPOS AFTER THE
;    CLEAN-WIPE, AND SIMILARILY FOR MAX-CURSORPOS AND MAX-RESET-CURSORPOS.
;  (ED-DISPLAY-CLEAN-WIPE <LINE> <SCREEN LOCATION>) INVOKES A CLEAN WIPE.
;    AN ATTEMPT IS MADE TO WORK THINGS OUT SUCH THAT LINE <LINE> STARTS ON THE
;    <SCREEN-LOCATION TH) PHYSICAL LINE ON THE SCREEN.  HOWEVER, IT SHOULD
;    NOT BE AUTOMATICALLY ASSUMED THAT ED-DISPLAY-CLEAN-WIPE WILL SUCCEED IN
;    LOCATING IT EXACTLY THERE.
;  (ED-LINE-REDISPLAY <LINE>)
;    WILL ATTEMPT TO LEAVE AS MUCH OF THE CURRENT SCREEN CONTENTS AS POSSIBLE.
;    IE, IT STARTS AT THE TOP OF THE DISPLAY WINDOW AND SKIPS OVER ANY
;    SCREEN LINES THAT HAVENT BEEN CHANGED AND MATCHING TEXT LINES.
;    HOWEVER, IF THIS PROCEDURE WOULD CAUSE LINE <LINE> TO BE DISPLAYED AT
;    A PHYSICAL LINE NUMBER OUT OF RANGE (SEE ABOVE) A CLEAN-WIPE OCCURS.
;  (ED-PARTIAL-LINE-REDISPLAY <LINE> <CHARPOS> <SCREEN-VERTICAL LOCATION>)
;    SAYS UPDATE SCREEN ASSUMING THAT ONLY <LINE> IN CHARACTER POSITIONS
;    GREATER THAN OR EQUAL TO <CHARPOS> HAS CHANGED.  THIS LINE MUST BE
;    BEING CURRENTLY DISPLAYED STARTING AT <SCREEN-VERTICAL LOCATION>.
;    ED-PARTIAL-LINE-REDISPLAY COMPUTES THE HORIZONAL SCREEN COORDINATE
;    CORRESPONDING TO <CHARPOS>, AND DOES A (IO-SET-CURSORPOS ..) TO THERE.
;    IT THEN REDISPLAYS THE REST OF THE LINE AND DOES A CLEAR END OF LINE.
;    IT THEN DOES AN RCPOS TO SEE IF THE LINE CAUSED MORE CONTINUATIONS THIS TIME
;    THAN LAST. IF NOT, IT RETURNS. IF SO, IT DOES A (ED-LINE-REDISPLAY <LINE>).
;  (ED-REDISPLAY-CHARACTER-ADD <LINE> <CHARPOS> <NUMBER>
;		<SCREEN-VERTICAL-LOCATION><SCREEN-HORIZONAL-LOCATION>)
;       ASSUMES THAT THE CURSOR (OF THE ACTIVE BUFFER) IS AT THE
;	SPECIFIED SCREEN LOCATION AND THAT THIS CORRESPONDS TO 
;	<LINE> <CHARPOS> IN THE BUFFER. PRESUMABLY, <NUMBER> OF CHARACTERS
;	HAVE BEEN INSERTED.  THUS <NUMBER> OF CHARACTERS ARE OUTPUTTED,
;	A SAVE CURSOR POSITION DONE, THE REST OF THE LINE OUTPUTED, AND
;	A RESTORE CURSOR POSITION DONE. AS ABOVE, AN ED-LINE-REDISPLAY
;	MAY THEN BE DONE IF NECESSARY.
;  (ED-DISPLAY-CURSOR-POS <LINE> <CHARPOS>) MOVES CURSOR TO DISPLAY
;	POSITION CORRESPONDING THE THE ARGS.
;  KEEPING TRACK OF THE CURSORPOS:
;   TWO VARIABLES IO-CURSORPOS-V AND IO-CURSORPOS-H ATTEMPT TO KEEP TRACK
;   OF THE CURSORPOS, BUT EITHER MAY BE NIL INDICATING THAT ITS NOT
;   REALLY SURE RIGHT NOW.  EACH DISPLAY WINDOW HAS TWO VARIABLES
;   ED-WINDOW-CURSORPOS-V AND ED-WINDOW-CURSORPOS-H WHICH ATTEMPT
;   TO REMEMBER WHERE THE "LOGICAL" CURSOR ASSOCIATED WITH THIS WINDOW IS
;   (WAS), BUT THESE MAY AT TIMES BE NIL ALSO.

(SETQ EDFN '(ED-INITIALIZE ED-CREATE-LINE-BLOCK ED-CREATE-BUFFER 
	 ED-CREATE-DISPLAY-WINDOW ED-OPEN-LINE ED-CLOSE-LINE ED-INTRA-LINE-RELOCATE 
	 ED-INTRA-LINE-RELOCATE-ARRAY ED-INTRA-LINE-RELOCATE-LINE 
	 ED-INSERT-STRING ED-INSERT-STRING-IN-LINE ED-FILL-BLANKS ED-FILL-STRING 
	 ED-ASSURE-ROOM-IN-LINE ED-EXPAND-LINE ED-INSERT-STRING-WITHIN-LINE 
	 ED-DELETE-CHARS ED-DELETE-CHARS-IN-LINE 
	 ED-DELETE-CHARS-WITHIN-LINE 
	 ED-ADD-LINE-TO-BUFFER ED-GET-STRING-LENGTH 
	 ED-GET-LINE-NUMBER-FROM-IDENTITY 
	 ED-CLEAN-WIPE ED-DISPLAY-WINDOW-UPDATE ED-OUTPUT-LINE 
         ED-COMPUTE-#-PHYSICAL-LINES ED-CLEAR-DISPLAY-WINDOW 
	 ALL-STORE ALL-FILL 
	 ED ED-GET-COMMAND ED-GET-COMMAND-CHARACTER ED-EXECUTE-COMMAND 
	 ED-INTERPRET-RETURNED-VALUE ED-COMMAND-RESET 
	 (INITIALIZE-ARRAY ED-COMMAND-DISPATCH-TABLE WORKING-STORAGE-AREA 
		ART-Q (600) NIL NIL ED-INITIAL-COMMAND-DISPATCH-TABLE)
))

;DETAIL SPECIFICATIONS

(SETQ ED-STORAGE-AREAS '(ED-LINE-BUFFER-AREA ED-EDITOR-ARRAYS-AREA))

;BUFFER
   ;ARRAY LEADER
(SETQ ED-BUFFER-LEADER-QS '(
    ED-BUFFER-FILL-POINTER ED-BUFFER-ASCENDING-LINE-NUMBER-COUNT 
    ED-BUFFER-SET-WINDOW-WIDTH ED-BUFFER-BUFFER-POINTER-ARRAY 
    ED-BUFFER-OPEN-LINE-NUMBER ED-BUFFER-OPEN-LINE-POINTER 
    ED-BUFFER-OPEN-LINE-CHANGES ED-BUFFER-STRUCTURE-DESCRIPTION-LIST 
    ED-BUFFER-HISTORY-LIST 
    ED-BUFFER-OPTIONS-AND-MODES ED-BUFFER-OLD-COPY-OPEN-LINE))

;THESE VARIABLES CORRESPOND TO THE LIKE NAMED ONES ABOVE FOR THE OPEN BUFFER
;NOTE ONLY THE MOST FREQUENTLY USED VARIABLES ABOVE ARE INCLUDED.
(SPECIAL 
    ED-OPEN-BUFFER ED-OPEN-LINE-NUMBER ED-OPEN-LINE-POINTER 
    ED-OPEN-LINE-CHANGES ED-HISTORY-LIST ED-OPTIONS-AND-MODES)

;LINE
   ;ARRAY-LEADER
(SETQ ED-LINE-LEADER-QS '(ED-LINE-FILL-POINTER ED-LINE-IDENTITY-NUMBER 
    ED-LINE-INCARNATION-NUMBER 
    ED-LINE-#-PHYSICAL-LINES ED-LINE-NET-OPENS-LESS-CLOSES ED-LINE-LEFT-CLOSE-DEPTH 
    ED-LINE-RIGHT-OPEN-DEPTH))

;DISPLAY-WINDOW
   ;ARRAY-LEADER
(SETQ ED-DISPLAY-WINDOW-LEADER-QS '(ED-WINDOW-FILL-POINTER 
   ED-WINDOW-HEIGHT ED-WINDOW-WIDTH 
   ED-WINDOW-HORIZONAL-OFFSET ED-WINDOW-VERTICAL-OFFSET ED-WINDOW-ASSOCIATED-BUFFER 
   ED-WINDOW-MIN-CURSORPOS ED-WINDOW-MAX-CURSORPOS ED-WINDOW-MIN-RESET-CURSORPOS
   ED-WINDOW-MAX-RESET-CURSORPOS ED-WINDOW-LOGICAL-CURSORPOS-V
   ED-WINDOW-LOGICAL-CURSORPOS-H ED-WINDOW-CLEAR-WITH-FORM-FEED
   ED-WINDOW-USE-SYSTEM-HORIZONAL-WRAPAROUND))

;BUFFER-POINTER-ARRAY
    ;ARRAY-LEADER
(SETQ ED-BFA-LEADER-QS '(ED-BFA-FILL-POINTER))

;STRUCTURE-TABLE-ARRAY
    ;ARRAY-LEADER
(SETQ ED-STRUCT-TABLE-LEADER-QS '(ED-STRUCT-TABLE-FILL-POINTER 
    ED-STRUCTURE-TABLE-FUNCTION))

(SETQ ED-CONSTANT-PARAMETER-LISTS '(ED-CONSTANT-PARAMETER-LISTS 
		ED-BUFFER-LEADER-QS ED-LINE-LEADER-QS 
		ED-DISPLAY-WINDOW-LEADER-QS ED-STRUCT-TABLE-LEADER-QS 
		ED-STORAGE-AREAS))

(MAPCAR (FUNCTION SPECIAL-LIST) ED-CONSTANT-PARAMETER-LISTS)

;EDITOR SYMBOLIC CONSTANTS
(SPECIAL ED-INFINITY ED-DISPLAY-WINDOW-STEP ED-BFA-STEP ED-STRUCTURE-TABLE-STEP)
;IO VARIABLES
(SPECIAL IO-TTY-VERTICAL-SIZE IO-TTY-HORIZONAL-SIZE IO-CURSORPOS-V 
	IO-CURSORPOS-H)
;EDITOR FREE VARIABLES
(SPECIAL ED-DISPLAY-WINDOW)

(DEFUN ED-INITIALIZE NIL 
  (PROG ()
	(SETQ ED-INFINITY 1000000)
	(SETQ ED-BFA-STEP 2)
	(SETQ ED-STRUCTURE-TABLE-STEP 3)
	(SETQ ED-DISPLAY-WINDOW-STEP 2)
	(Q-BRINGOVER ED-BUFFER-LEADER-QS)	;MACRO EXPANDS TO SETQ THAT CAUSES
	(Q-BRINGOVER ED-LINE-LEADER-QS)		;LM SYM TO BE SET EQUAL TO MACLISP SYM
	(Q-BRINGOVER ED-DISPLAY-WINDOW-LEADER-QS)
	(Q-BRINGOVER ED-STRUCT-TABLE-LEADER-QS)
	(Q-BRINGOVER ED-CONSTANT-PARAMETER-LISTS)
	(SETQ ED-LINE-BUFFER-AREA (DEFINE-AREA 'ED-LINE-AREA 10000))
	(SETQ ED-EDITOR-ARRAYS-AREA (DEFINE-AREA 'ED-ARRAYS-AREA 1000))
	(ASSIGN-VALUES ED-BUFFER-LEADER-QS 0)
	(ASSIGN-VALUES ED-LINE-LEADER-QS 0)
	(ASSIGN-VALUES ED-DISPLAY-WINDOW-LEADER-QS 0)
	(ASSIGN-VALUES ED-STRUCT-TABLE-LEADER-QS 0)
	(SETQ ED-OPEN-BUFFER NIL)
	(SETQ ED-OPEN-LINE-NUMBER NIL)
	(SETQ ED-OPEN-LINE-POINTER NIL)
	(SETQ ED-OPEN-LINE-CHANGES NIL)
	(SETQ ED-HISTORY-LIST NIL)
	(SETQ ED-OPTIONS-AND-MODES NIL)
	(IO-INITIALIZE)
	(SETQ ED-DISPLAY-WINDOW 
	  (ED-CREATE-DISPLAY-WINDOW T T IO-TTY-VERTICAL-SIZE IO-TTY-HORIZONAL-SIZE))
))
      
(DEFUN ED-CREATE-LINE-BLOCK (&OPTIONAL (SIZE 120.) (LINE-IDENTITY -1))
  (PROG ()
	(COND ((MINUSP LINE-IDENTITY)
		(SETQ LINE-IDENTITY 
			(ARRAY-LEADER ED-OPEN-BUFFER 
				      ED-BUFFER-ASCENDING-LINE-NUMBER-COUNT))
		(STORE-ARRAY-LEADER ED-OPEN-BUFFER 
				    ED-BUFFER-ASCENDING-LINE-NUMBER-COUNT 
				   (1+ LINE-IDENTITY))))
	(RETURN (MAKE-ARRAY-BLOCK ED-LINE-BUFFER-AREA 'ART-STRING (LIST SIZE) 
			NIL (LIST ED-INFINITY ED-INFINITY ED-INFINITY 
				  -1 0 LINE-IDENTITY 0)))
))

(DEFUN ED-CREATE-BUFFER (&OPTIONAL (SIZE 100) (BPA-SIZE 10))
  (PROG (V BPA)
	(COND ((NULL (MEMQ 'ED-ARRAYS-AREA AREA-LIST))
		(ED-INITIALIZE)))
	(SETQ BPA (MAKE-ARRAY-BLOCK ED-EDITOR-ARRAYS-AREA 'ART-Q-LIST 
		        (LIST (* BPA-SIZE ED-BFA-STEP))
			NIL '(0)))
	(SETQ V (MAKE-ARRAY-BLOCK ED-EDITOR-ARRAYS-AREA 'ART-Q-LIST (LIST SIZE)
			NIL (LIST NIL NIL NIL NIL NIL NIL NIL BPA -1 0 0))) 
	(RETURN V)))

(DEFUN ED-CREATE-DISPLAY-WINDOW (CLEAR-WITH-FF-P USE-SYS-HORIZ-WRAP-P 
	WINDOW-HEIGHT-IN-LINES WINDOW-WIDTH-IN-CHARACTERS 
	&OPTIONAL  (WINDOW-VERTICAL-OFFSET-IN-LINES 0)
		   (WINDOW-HORIZ-OFFSET-IN-CHARACTERS 0))
  (PROG (V)
	(SETQ V (MAKE-ARRAY-BLOCK ED-EDITOR-ARRAYS-AREA 'ART-Q-LIST 
			(LIST (* WINDOW-HEIGHT-IN-LINES ED-DISPLAY-WINDOW-STEP))
			NIL 
			(LIST USE-SYS-HORIZ-WRAP-P 
					;ED-WINDOW-USE-SYSTEM-HORIZONAL-WRAPAROUND
			      CLEAR-WITH-FF-P 
					;ED-WINDOW-CLEAR-WITH-FF
			      NIL	;ED-WINDOW-LOGICAL-CURSORPOS-H
			      NIL	;ED-WINDOW-LOGICAL-CURSORPOS-V
			      10	;ED-WINDOW-MAX-RESET-CURSORPOS
			      (- WINDOW-HEIGHT-IN-LINES 10) 
					;ED-WINDOW-MIN-RESET-CUSORPOS
			      (- WINDOW-HEIGHT-IN-LINES 3)  
					;ED-WINDOW-MAX-CUSORPOS
			      2		;ED-WINDOW-MIN-CURPOS
			      NIL 	;ED-WINDOW-ASSOCIATED-BUFFER
			      WINDOW-VERTICAL-OFFSET-IN-LINES 
					;ED-WINDOW-VERTICAL-OFFSET
			      WINDOW-HORIZ-OFFSET-IN-CHARACTERS  
					;ED-WINDOW-HORIZONAL-OFFSET
			      WINDOW-WIDTH-IN-CHARACTERS  
					;ED-WINDOW-WIDTH
			      WINDOW-HEIGHT-IN-LINES 
					;ED-WINDOW-HEIGHT
			      (* WINDOW-HEIGHT-IN-LINES ED-DISPLAY-WINDOW-STEP)
					;ED-WINDOW-FILL-POINTER
					)))
	(RETURN V)))



(DEFUN ED-ADD-LINE-TO-BUFFER NIL 
  (PROG (V NEW-BUFFER)
   L	(COND ((SETQ V (FILL-ARRAY ED-OPEN-BUFFER NIL))
		(RETURN V)))
	(SETQ NEW-BUFFER (ED-CREATE-BUFFER (+ (ARRAY-DIMENSION-N 1 ED-OPEN-BUFFER)
					      100)))
	(%COPY-ARRAY-CONTENTS-AND-LEADER ED-OPEN-BUFFER NEW-BUFFER)
	(SETQ ED-OPEN-BUFFER NEW-BUFFER)
	(GO L)))

(DEFUN ED-OPEN-LINE (LINE-NUMBER)
  (PROG (OL OL-SIZE NL-SIZE TEM LINE-IDENTITY)
	(COND ((VAR-BLANK-P 'ED-OPEN-BUFFER) (SETQ ED-OPEN-BUFFER (ED-CREATE-BUFFER))))
	(SETQ NL-SIZE 120.)
	(SETQ LINE-IDENTITY -1)
	(COND ((NULL ED-OPEN-LINE-NUMBER)
		(GO L1))
	      ((= ED-OPEN-LINE-NUMBER LINE-NUMBER) (RETURN T)))  ;LINE ALREADY OPEN
	(ED-CLOSE-LINE)
    L1	(STORE-ARRAY-LEADER ED-OPEN-BUFFER ED-BUFFER-OLD-COPY-OPEN-LINE NIL)
	(COND ((MINUSP LINE-NUMBER)
		(SETQ LINE-NUMBER (ED-ADD-LINE-TO-BUFFER))
		(GO L2)))	 ;OPEN FRESH NEW LINE
    L1A	(COND ((NOT (< LINE-NUMBER 
		      (ARRAY-LEADER ED-OPEN-BUFFER ED-BUFFER-FILL-POINTER)))
		(ED-ADD-LINE-TO-BUFFER)
		(GO L1A))	;MAKE SURE INDICATE LINE EXISTS IN BUFFER
	      ((NULL (SETQ OL (FUNCALL ED-OPEN-BUFFER LINE-NUMBER))) (GO L2))
	      ((> (SETQ LINE-IDENTITY (ARRAY-LEADER OL ED-LINE-IDENTITY-NUMBER)
			OL-SIZE (ARRAY-DIMENSION-N 1 OL)) 100.)
		(SETQ NL-SIZE (+ 20. OL-SIZE))))
    L2	(SETQ ED-OPEN-LINE-POINTER
		 (ED-CREATE-LINE-BLOCK NL-SIZE LINE-IDENTITY))
	(COND ((NULL OL-SIZE) (GO X)))
	(STORE-ARRAY-LEADER ED-OPEN-BUFFER ED-BUFFER-OLD-COPY-OPEN-LINE OL)
 	(%COPY-ARRAY-CONTENTS-AND-LEADER OL ED-OPEN-LINE-POINTER)
	(STORE-ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-INCARNATION-NUMBER 
		(1+ (ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-INCARNATION-NUMBER)))
    X	(SETQ ED-OPEN-LINE-NUMBER LINE-NUMBER)
	(SETQ ED-OPEN-LINE-CHANGES NIL)
	(STORE (FUNCALL ED-OPEN-BUFFER ED-OPEN-LINE-NUMBER) ED-OPEN-LINE-POINTER)
	(RETURN T)))

(DEFUN ED-CLOSE-LINE NIL 
  (PROG (NL-SIZE OL)
	(COND ((NULL ED-OPEN-LINE-NUMBER) (RETURN T)))
	(SETQ NL-SIZE (ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-FILL-POINTER))
	(SETQ OL (ARRAY-LEADER ED-OPEN-BUFFER ED-BUFFER-OLD-COPY-OPEN-LINE))
	(ADJUST-ARRAY-SIZE ED-OPEN-LINE-POINTER
			  (COND ((ZEROP NL-SIZE) 1)
				(T NL-SIZE)))	;RETURN ANY EXTRA SPACE
	(ED-INTRA-LINE-RELOCATE)
;	(STORE (FUNCALL ED-OPEN-BUFFER ED-OPEN-LINE-NUMBER) ED-OPEN-LINE-POINTER)
	(SETQ ED-HISTORY-LIST 
		(CONS (LIST OL ED-OPEN-LINE-CHANGES)
		      ED-HISTORY-LIST))
	(SETQ ED-OPEN-LINE-NUMBER NIL)
	(SETQ ED-OPEN-LINE-POINTER NIL)
	(SETQ ED-OPEN-LINE-CHANGES NIL)
	(STORE-ARRAY-LEADER ED-OPEN-BUFFER ED-BUFFER-OLD-COPY-OPEN-LINE NIL)
	(RETURN T)))

(DEFUN ED-INTRA-LINE-RELOCATE NIL 
  (PROG (TEM)
	(ED-INTRA-LINE-RELOCATE-ARRAY 
		      (ARRAY-LEADER ED-OPEN-BUFFER ED-BUFFER-BUFFER-POINTER-ARRAY)
		       ED-BFA-STEP)
	(SETQ TEM (ARRAY-LEADER ED-OPEN-BUFFER ED-BUFFER-STRUCTURE-DESCRIPTION-LIST))
   L	(COND ((NULL TEM) (RETURN T))
	      ((ARRAY-LEADER (CAR TEM) ED-STRUCTURE-TABLE-FUNCTION))	;ITS A FUNCTION
	      (T (ED-INTRA-LINE-RELOCATE-ARRAY
				(CAR TEM) 
				ED-STRUCTURE-TABLE-STEP)))
	(SETQ TEM (CDR TEM))
	(GO L)))

(DEFUN ED-INTRA-LINE-RELOCATE-ARRAY (ARRAY INCR)
  (PROG (TOP IDX)
	(SETQ IDX 0)
	(SETQ TOP (ARRAY-LEADER ARRAY 0))
   L	(COND ((NOT (< IDX TOP)) (RETURN T))
	      ((NOT (= (FUNCALL ARRAY IDX) ED-OPEN-LINE-NUMBER)))
	      (T 
		(STORE (FUNCALL ARRAY (1+ IDX))
			(ED-INTRA-LINE-RELOCATE-LINE 
				(FUNCALL ARRAY (1+ IDX))))))
	(SETQ IDX (+ IDX INCR))
	(GO L)))

(DEFUN ED-INTRA-LINE-RELOCATE-LINE (CHAR-NUMBER)
   (PROG (LINE-CHANGES)
	(SETQ LINE-CHANGES ED-OPEN-LINE-CHANGES)
  L	(COND ((NULL LINE-CHANGES) (RETURN CHAR-NUMBER))
	      ((EQ (CAAR LINE-CHANGES) 'INSERT)
		(COND ((> CHAR-NUMBER (CADAR LINE-CHANGES))
			(SETQ CHAR-NUMBER (+ CHAR-NUMBER (CADDAR LINE-CHANGES))))))
	      ((EQ (CAAR LINE-CHANGES) 'DELETE)
		(COND ((< CHAR-NUMBER (CADAR LINE-CHANGES)))
		      ((< CHAR-NUMBER (+ (CADAR LINE-CHANGES) (CADDAR LINE-CHANGES)))
			(SETQ CHAR-NUMBER (CADAR LINE-CHANGES)))   ;CHAR WAS DELETED
		      (T (SETQ CHAR-NUMBER (- CHAR-NUMBER (CADDAR LINE-CHANGES))))))
	      (T (PRINT 'UNKNOWN-CODE-IN-LINE-CHANGES-LIST)
		 (PRINT (CAR LINE-CHANGES))))
	(SETQ LINE-CHANGES (CDR LINE-CHANGES))
	(GO L)))

(DEFUN ED-DELETE-CHARS (LINE-NUMBER CHAR-POSITION NUMBER)
  (PROG ()
	(ED-OPEN-LINE LINE-NUMBER)
	(ED-DELETE-CHARS-IN-LINE CHAR-POSITION NUMBER)
	(SETQ ED-OPEN-LINE-CHANGES 
		(CONS (LIST 'DELETE CHAR-POSITION NUMBER)
		      ED-OPEN-LINE-CHANGES))
	(RETURN T)))

(DEFUN ED-DELETE-CHARS-IN-LINE (CHAR-POSITION NUMBER)
  (PROG (LINE-LENGTH)
	(SETQ LINE-LENGTH (ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-FILL-POINTER))
	(COND ((NOT (< CHAR-POSITION LINE-LENGTH))
		(GO X))	;NO CHARS THAT FAR OUT
	      ((NOT (> LINE-LENGTH (+ CHAR-POSITION NUMBER)))
		(STORE-ARRAY-LEADER ED-OPEN-LINE-POINTER 
				    ED-LINE-FILL-POINTER 
				    CHAR-POSITION)
		(GO X)))  ;FLUSHING TO END OF LINE
	(ED-DELETE-CHARS-WITHIN-LINE NUMBER CHAR-POSITION)
 X	(RETURN T)))

;"STRING" TO INSERTING FUNCTIONS MAY BE EITHER A REGULAR STRING
;  OR A NUMBER WHICH SERVES AS A STRING OF LENGTH ONE CONTAINING THAT
;  CHARACTER.

(DEFUN ED-INSERT-STRING (STRING LINE-NUMBER CHAR-POSITION)
  (PROG ()
	(COND ((AND (NUMBERP STRING)
		    (NOT (= STRING 15)))
		(GO X1)))
    X1	(RETURN (ED-INSERT-CR-FREE-STRING STRING LINE-NUMBER CHAR-POSITION))
))

(DEFUN ED-INSERT-CR-FREE-STRING (STRING LINE-NUMBER CHAR-POSITION)
  (PROG ()
	(ED-OPEN-LINE LINE-NUMBER)
   	(ED-INSERT-STRING-IN-LINE STRING 
				  CHAR-POSITION)
	(SETQ ED-OPEN-LINE-CHANGES 
		(CONS (LIST 'INSERT CHAR-POSITION (ED-GET-STRING-LENGTH STRING))
		      ED-OPEN-LINE-CHANGES))
	(RETURN T)))

(DEFUN ED-INSERT-STRING-IN-LINE (STRING CHAR-POSITION)
  (PROG (LINE-LENGTH)
	(SETQ LINE-LENGTH (ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-FILL-POINTER))
	(COND ((> CHAR-POSITION LINE-LENGTH)
		(ED-FILL-BLANKS (- CHAR-POSITION LINE-LENGTH))
		(SETQ LINE-LENGTH 
			(ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-FILL-POINTER))))
						;CHAR POS DOESNT EXIST..
	(COND ((= CHAR-POSITION LINE-LENGTH)
		(ED-FILL-STRING STRING))
	      (T (ED-INSERT-STRING-WITHIN-LINE STRING CHAR-POSITION))) ))

(DEFUN ED-FILL-BLANKS (NUMBER)
  (PROG ()
	(ED-ASSURE-ROOM-IN-LINE NUMBER)
   L	(COND ((ZEROP NUMBER) (RETURN T))
	      ((NULL (FILL-ARRAY ED-OPEN-LINE-POINTER 40))
		(PRINT 'LOSE-AT-ED-LINE-FILL-BLANKS)))
	(SETQ NUMBER (1- NUMBER))
	(GO L)))

(DEFUN ED-FILL-STRING (STRING)
  (PROG (IDX NUMBER)
	(SETQ IDX 0)
	(SETQ NUMBER (ED-GET-STRING-LENGTH STRING))
	(ED-ASSURE-ROOM-IN-LINE NUMBER)
	(COND ((NUMBERP STRING)
		(COND ((NULL (FILL-ARRAY ED-OPEN-LINE-POINTER STRING))
			(GO LOSE)))
		(RETURN T)))
   L	(COND ((= IDX NUMBER) (RETURN T))
	      ((NULL (FILL-ARRAY ED-OPEN-LINE-POINTER (FUNCALL STRING IDX)))
		(GO LOSE)))
	(SETQ IDX (1+ IDX))
	(GO L)
  LOSE	(PRINT 'LOSE-AT-ED-FILL-STRING)
	(RETURN NIL)))

(DEFUN ED-ASSURE-ROOM-IN-LINE (AMOUNT)
  (PROG (CURRENT-SIZE)
	(COND ((< (SETQ CURRENT-SIZE (ARRAY-DIMENSION-N 1 ED-OPEN-LINE-POINTER))
		  (+ AMOUNT (ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-FILL-POINTER)))
		(ED-EXPAND-LINE (+ CURRENT-SIZE (MAX AMOUNT 100.)))))))

(DEFUN ED-EXPAND-LINE (NEW-SIZE)
  (PROG (NL)
	(SETQ NL (ED-CREATE-LINE-BLOCK NEW-SIZE 
			(ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-IDENTITY-NUMBER)))
	(%COPY-ARRAY-CONTENTS-AND-LEADER ED-OPEN-LINE-POINTER NL)
	(STORE-ARRAY-LEADER NL ED-LINE-INCARNATION-NUMBER 
		(1+ (ARRAY-LEADER NL ED-LINE-INCARNATION-NUMBER)))
	(SETQ ED-OPEN-LINE-POINTER NL)
	(RETURN T)))

(DEFUN ED-DELETE-CHARS-WITHIN-LINE (NUMBER CHAR-POS)
  (PROG (LINE-LENGTH CHAR-COUNT FROM-IDX TO-IDX)
	(SETQ CHAR-COUNT 
		(- (SETQ LINE-LENGTH
			(ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-FILL-POINTER))
		   (+ CHAR-POS NUMBER)))
	(SETQ TO-IDX CHAR-POS)
	(SETQ FROM-IDX (+ CHAR-POS NUMBER))
   L2	(STORE (FUNCALL ED-OPEN-LINE-POINTER TO-IDX)
	       (FUNCALL ED-OPEN-LINE-POINTER FROM-IDX))
	(COND ((NOT (ZEROP (SETQ CHAR-COUNT (1- CHAR-COUNT))))
		(SETQ TO-IDX (1+ TO-IDX))
		(SETQ FROM-IDX (1+ FROM-IDX))
		(GO L2)))
	(STORE-ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-FILL-POINTER 
		(- LINE-LENGTH NUMBER))
	(RETURN T)))

(DEFUN ED-INSERT-STRING-WITHIN-LINE (STRING CHAR-POS)
  (PROG (STRING-LENGTH LINE-LENGTH CHAR-COUNT FROM-IDX TO-IDX)
	(SETQ STRING-LENGTH (ED-GET-STRING-LENGTH STRING))
    L	(ED-ASSURE-ROOM-IN-LINE STRING-LENGTH)
	(SETQ CHAR-COUNT 
		(- (SETQ LINE-LENGTH 
			 (ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-FILL-POINTER))
		   CHAR-POS))	;# OF CHARS IN LINE PAST WHERE WANT TO INSERT
	(COND ((MINUSP CHAR-COUNT)
		(ED-FILL-BLANKS (MINUS CHAR-COUNT))
		(GO L))
	      ((ZEROP CHAR-COUNT)
		(ED-FILL-STRING STRING)
		(GO X)))
    L1	(SETQ FROM-IDX (1- LINE-LENGTH))
	(SETQ TO-IDX (+ FROM-IDX STRING-LENGTH))
	(STORE-ARRAY-LEADER ED-OPEN-LINE-POINTER ED-LINE-FILL-POINTER (1+ TO-IDX))
    L2	(STORE (FUNCALL ED-OPEN-LINE-POINTER TO-IDX)
	       (FUNCALL ED-OPEN-LINE-POINTER FROM-IDX))
	(COND ((NOT (ZEROP (SETQ CHAR-COUNT (1- CHAR-COUNT))))
		(SETQ TO-IDX (1- TO-IDX))
		(SETQ FROM-IDX (1- FROM-IDX))
		(GO L2)))
	(SETQ CHAR-COUNT STRING-LENGTH)
	(SETQ TO-IDX CHAR-POS)
	(COND ((NUMBERP STRING)
		(STORE (FUNCALL ED-OPEN-LINE-POINTER TO-IDX) STRING)
		(GO X)))
	(SETQ FROM-IDX 0)
    L3	(COND ((ZEROP CHAR-COUNT) (GO X)))
	(STORE (FUNCALL ED-OPEN-LINE-POINTER TO-IDX) (FUNCALL STRING FROM-IDX))
	(SETQ TO-IDX (1+ TO-IDX))
	(SETQ FROM-IDX (1+ FROM-IDX))
	(SETQ CHAR-COUNT (1- CHAR-COUNT))
	(GO L3)
   X	(RETURN T)
))


(DEFUN ED-GET-STRING-LENGTH (STRING)
   (PROG (IDX)
	(COND ((NUMBERP STRING) (RETURN 1)))
	(COND ((ARRAY-HAS-LEADER-P STRING) (RETURN (ARRAY-LEADER STRING 0))))
	(SETQ IDX 0)
L	(COND ((= (FUNCALL STRING IDX) 200) (RETURN IDX)))
	(SETQ IDX (1+ IDX))
	(GO L)))

(DEFUN Q-BRINGOVER MACRO (X)
	(LIST 'SETQ (CADR X) (LIST 'QUOTE (SYMEVAL (CADR X)))))	;SET SYM IN Q-LISP TO
								;ITS PDP-10 LISP VALUE

(DEFUN ED-CLEAN-WIPE (LINE PHYSICAL-LINES-ABOVE-LINE)
   (PROG (TOP-LINE CNT LINE-POINTER PHYS-LINES MAX-LINE PHYS-LINE) 
	(SETQ TOP-LINE LINE)		;LOCATE LINE WHICH WILL BE TOP ONE DISPLAYED
	(SETQ CNT PHYSICAL-LINES-ABOVE-LINE)
	(COND ((NULL ED-OPEN-BUFFER) (GO NULL-X)))
	(SETQ MAX-LINE (ARRAY-LEADER ED-OPEN-BUFFER ED-BUFFER-FILL-POINTER))
							;MAX LINE IN BUFFER
	(COND ((NOT (< LINE MAX-LINE)) (GO NULL-X)))
;SCAN UPWARD FROM LINE UNTIL REACH TOP OR PASS REQUIRED NUMBER OF LINES
  L	(COND ((OR (ZEROP CNT) (ZEROP TOP-LINE)) (GO D)))  ;TOP LINE IS NOW ONE TO BE
	(SETQ TOP-LINE (1- TOP-LINE))
	(SETQ LINE-POINTER (FUNCALL ED-OPEN-BUFFER TOP-LINE))
	(COND ((NULL LINE-POINTER)	;AT TOP OF DISPLAY
		(SETQ CNT (1- CNT))	;NULL LINE TAKES ONE LINE TO DISPLAY
		(GO L))
	      ((NOT (= (SETQ PHYS-LINES 
			    (ARRAY-LEADER LINE-POINTER ED-LINE-#-PHYSICAL-LINES))
			ED-INFINITY))
		(GO L1))
	      (T (STORE-ARRAY-LEADER LINE-POINTER ED-LINE-#-PHYSICAL-LINES 
			(SETQ PHYS-LINES (ED-COMPUTE-#-PHYSICAL-LINES LINE-POINTER)))))
  L1	(COND ((NOT (> PHYS-LINES CNT))
		(SETQ CNT (- CNT PHYS-LINES))
		(GO L))			;KEEP SCANNING
	      ((> PHYS-LINES (+ CNT 2)) (SETQ TOP-LINE (1+ TOP-LINE))))
					;ALLOW DESIRED LINE TO BE PUSHED DOWN UP TO
					;TWO LINES, BUT IF IT WOULD BE MORE THAN THAT
					;FLUSH LINE INSTEAD.
;TOP-LINE NOW HAS LINE NUMBER OF LINE THAT IS TO BE DISPLAYED AT TOP OF PHYSICAL
;DISPLAY EXCEPT SCAN BACK DOWN OVER ANY NULL LINES..
   D	(SETQ LINE-POINTER (FUNCALL ED-OPEN-BUFFER TOP-LINE))
	(COND (LINE-POINTER (GO D1)) ;DONT WASTE DISPLAY SPACE 
				     ;AT TOP ON BLANK LINES
	      ((NOT (< (SETQ TOP-LINE (1+ TOP-LINE)) MAX-LINE)) (GO NULL-X)))
	(GO D)
   D1	(ED-DISPLAY-WINDOW-UPDATE TOP-LINE)	;NOW TOP-LINE REALLY HAS IT.
	(RETURN T)
  NULL-X(RETURN (ED-CLEAR-DISPLAY-WINDOW))
))

;MAKE SURE DISPLAY WINDOW CORRESPONDS TO ACTUAL BUFFER.  TOP-LINE IS TO APPEAR
; ON FIRST LINE OF DISPLAY

(DEFUN ED-DISPLAY-WINDOW-UPDATE (TOP-LINE)
  (PROG (PHYS-LINE WINDOW-P MAX-WINDOW-P LINE-POINTER)
   D1   (SETQ MAX-WINDOW-P (ARRAY-LEADER ED-DISPLAY-WINDOW ED-WINDOW-FILL-POINTER))
	(SETQ PHYS-LINE 0)		;PHYSICAL LINE ON SCREEN ON
	(SETQ WINDOW-P 0)		;INDEX TO WINDOW ARRAY
   D2	(COND ((NOT (< WINDOW-P MAX-WINDOW-P))
		(RETURN T)))		;DISPLAYED AS MUCH AS WILL FIT IN WINDOW
	(SETQ LINE-POINTER (FUNCALL ED-OPEN-BUFFER TOP-LINE))
	(COND ((NULL LINE-POINTER)
		(COND ((FUNCALL ED-DISPLAY-WINDOW WINDOW-P)	;LINE NULL,
			(IO-SET-CURSORPOS PHYS-LINE 0)		;CLEAR SCREEN UNLESS
			(IO-CLEAR-END-OF-LINE)			;ALREADY IS
			(STORE (FUNCALL ED-DISPLAY-WINDOW WINDOW-P) NIL))))
	      ((AND (EQ (FUNCALL ED-DISPLAY-WINDOW WINDOW-P)
			(ARRAY-LEADER LINE-POINTER ED-LINE-IDENTITY-NUMBER))
		    (EQ (FUNCALL ED-DISPLAY-WINDOW (1+ WINDOW-P))
			(ARRAY-LEADER LINE-POINTER ED-LINE-INCARNATION-NUMBER)))
		(GO D3))	;ITS THERE, JUST SKIP OVER CONTINUATIONS		
	      (T (GO D5)))	;GO OUTPUT IT ON SCREEN
	(SETQ WINDOW-P (+ WINDOW-P ED-DISPLAY-WINDOW-STEP))
    D4	(SETQ PHYS-LINE (1+ PHYS-LINE))
 	(SETQ TOP-LINE (1+ TOP-LINE))
	(GO D2)
    D3	(SETQ WINDOW-P (+ WINDOW-P ED-DISPLAY-WINDOW-STEP))
	(COND ((NOT (< WINDOW-P MAX-WINDOW-P))
		(RETURN T))
	      ((EQ (FUNCALL ED-DISPLAY-WINDOW WINDOW-P) -1)
		(SETQ PHYS-LINE (1+ PHYS-LINE))		;THIS LINE TAKEN UP WITH 
		(GO D3)))				;CONTINUATION OF MATCHED LINE
	(GO D4)
;OUTPUT LINE POINTED TO BY LINE-POINTER ON PHYS-LINE
    D5	(MULTIPLE-VALUE (PHYS-LINE WINDOW-P)
		(ED-OUTPUT-LINE PHYS-LINE LINE-POINTER WINDOW-P))
	(GO D4)))

(DEFUN ED-LINE-REDISPLAY (LINE)
  (PROG (PHYS-LINE WINDOW-P LINE-POINTER TOP-LINE-IDENTITY MAX-LINE S-LINE 
	 TOP-LINE)
	(COND ((NULL ED-OPEN-BUFFER) (GO NULL-X)))
	(SETQ MAX-LINE (ARRAY-LEADER ED-OPEN-BUFFER ED-BUFFER-FILL-POINTER))
	(COND ((NOT (< LINE MAX-LINE)) (GO NULL-X)))
	(SETQ TOP-LINE-IDENTITY (FUNCALL ED-DISPLAY-WINDOW 0))
	(COND ((NULL TOP-LINE-IDENTITY) (GO NULL-X)))
	(COND ((NULL (SETQ TOP-LINE 
			(ED-GET-LINE-NUMBER-FROM-IDENTITY TOP-LINE-IDENTITY (1+ LINE))))
		(GO NULL-X)))

  L2	(SETQ WINDOW-P 0)
	(SETQ PHYS-LINE 0)
  L3
))

;SCAN IN BUFFER TRYING TO FIND LINE INDEX OF LINE WITH IDENTITY IDENTITY.
;GIVE UP WHEN GET TO INDEX MAX-LINE

(DEFUN ED-GET-LINE-NUMBER-FROM-IDENTITY (IDENTITY MAX-LINE)
  (PROG (S-LINE)
	(SETQ S-LINE 0)
  L	(COND ((> S-LINE END-LINE)	;DONT SCAN BEYOND LINE TRYING TO POSITION
		(RETURN NIL))
	      ((NULL (SETQ LINE-POINTER (FUNCALL ED-OPEN-BUFFER S-LINE)))
		(GO L1))
	      ((= (ARRAY-LEADER LINE-POINTER ED-LINE-IDENTITY-NUMBER)
		   TOP-LINE-IDENTITY)
		(RETURN S-LINE)))	;FOUND IT
  L1	(SETQ S-LINE (1+ S-LINE))
	(GO L)
))

;DISPLAY LINE <LINE-POINTER> AT <PHYS-LINE> PHYSICAL LINE AND <WINDOW-P> POSITION
; IN ED-DISPLAY-WINDOW.
;RETURN PAIR <NEXT-AVAILABLE-PHYS-LINE> <NEXT-AVAILABLE-WINDOW-INDEX>
; PHYS-LINE AND WINDOW-INDEX ARE INCREMENTED ONLY TO ACCOUNT FOR CONTINUATION LINES
; IF NONE, THEY WILL BE RETURNNED SAME AS GIVEN

(DEFUN ED-OUTPUT-LINE (PHYS-LINE LINE-POINTER WINDOW-P)
  (PROG (CONTINUATION-LINES)
	(IO-SET-CURSORPOS PHYS-LINE 0)
	(IO-CLEAR-END-OF-LINE)		;CLEAR STUFF
	(IO-FS-BLOCK-TYO LINE-POINTER)
	(IO-READ-CURSORPOS)
	(STORE (FUNCALL ED-DISPLAY-WINDOW WINDOW-P)
	       (ARRAY-LEADER LINE-POINTER ED-LINE-IDENTITY-NUMBER))
	(STORE (FUNCALL ED-DISPLAY-WINDOW (1+ WINDOW-P))
	       (ARRAY-LEADER LINE-POINTER ED-LINE-INCARNATION-NUMBER))
	(SETQ CONTINUATION-LINES (- IO-CURSORPOS-V PHYS-LINE))
	(COND ((NOT (ZEROP CONTINUATION-LINES))	;IF HAVE GONE TO NEW LINE
		(IO-CLEAR-END-OF-LINE)))	;CLEAR REST OF IT
	(STORE-ARRAY-LEADER LINE-POINTER ED-LINE-#-PHYSICAL-LINES 
			(1+ CONTINUATION-LINES))
    D5L	(SETQ WINDOW-P (+ WINDOW-P ED-DISPLAY-WINDOW-STEP))
	(COND ((OR (ZEROP CONTINUATION-LINES)
	           (NOT (< WINDOW-P MAX-WINDOW-P)))
		(RETURN PHYS-LINE WINDOW-P)))
	(STORE (FUNCALL ED-DISPLAY-WINDOW WINDOW-P)		;IDENTITY NUMBER FOR
								;CONTINUATION SAME AS
	       (ARRAY-LEADER LINE-POINTER ED-LINE-IDENTITY-NUMBER))	;FOR MAIN LINE
	(STORE (FUNCALL ED-DISPLAY-WINDOW (1+ WINDOW-P)) -1)	;INCARNATION NUMBER -1
								;FOR CONTINUATION LINE
	(SETQ PHYS-LINE (1+ PHYS-LINE))
	(SETQ CONTINUATION-LINES (1- CONTINUATION-LINES))
	(GO D5L)))

(DEFUN ED-CLEAR-DISPLAY-WINDOW NIL
  (PROG (MODE LINE-NUMBER MAX-LINE LINE-WIDTH HORIZ-OFF VERT-OFF) 
	(SETQ MODE (ARRAY-LEADER ED-DISPLAY-WINDOW ED-WINDOW-CLEAR-WITH-FORM-FEED))
	(SETQ LINE-NUMBER 0)
	(SETQ MAX-LINE (ARRAY-LEADER ED-DISPLAY-WINDOW ED-WINDOW-HEIGHT))
	(SETQ VERT-OFF (ARRAY-LEADER ED-DISPLAY-WINDOW ED-WINDOW-VERTICAL-OFFSET))
	(SETQ HORIZ-OFF (ARRAY-LEADER ED-DISPLAY-WINDOW ED-WINDOW-HORIZONAL-OFFSET))
	(COND ((EQ MODE T)
		(IO-CLEAR-SCREEN)
		(GO X))
	      ((EQ MODE 'USE-CLEAR-EOL)
		(GO L1)))
	(SETQ LINE-WIDTH (ARRAY-LEADER ED-DISPLAY-WINDOW ED-WINDOW-WIDTH))
   L2	(COND ((NOT (< LINE-NUMBER MAX-LINE))
		(GO X)))
	(IO-SET-CURSORPOS (+ VERT-OFF LINE-NUMBER) HORIZ-OFF)
	(IO-OUTPUT-BLANKS LINE-WIDTH)
	(SETQ LINE-NUMBER (1+ LINE-NUMBER))
	(GO L2)
   L1	(COND ((NOT (< LINE-NUMBER MAX-LINE))
		(GO X)))
	(IO-SET-CURSORPOS (+ VERT-OFF LINE-NUMBER) HORIZ-OFF)
	(IO-CLEAR-END-OF-LINE)
	(SETQ LINE-NUMBER (1+ LINE-NUMBER))
	(GO L1)
   X	(ALL-STORE ED-DISPLAY-WINDOW NIL)
	(RETURN T)))

	
(DEFUN ALL-FILL (ARRAY DATA)
  (PROG NIL 
     L	(COND ((NULL (FILL-ARRAY ARRAY DATA)) (RETURN T)))
	(GO L)))

(DEFUN ALL-STORE (ARRAY DATA)
  (PROG (LIM IDX)
	(SETQ IDX 0)
	(SETQ LIM (ARRAY-DIMENSION-N 1 ARRAY))
   L	(COND ((NOT (< IDX LIM))
		(RETURN T)))
	(STORE (FUNCALL ARRAY IDX) DATA)
	(SETQ IDX (1+ IDX))
	(GO L)))

(DEFUN ED-COMPUTE-#-PHYSICAL-LINES (STRING)
  (PROG (STRING-LENGTH IDX CHAR HORIZ-POS LINE-COUNT LINE-LENGTH)
	(SETQ STRING-LENGTH 
		(COND ((ARRAY-HAS-LEADER-P STRING)
			(ARRAY-LEADER STRING 0))
		      (T (ARRAY-DIMENSTION-N 1 STRING))))
	(COND ((< STRING-LENGTH 
		  (SETQ LINE-LENGTH (FUNCALL ED-DISPLAY-WINDOW ED-WINDOW-WIDTH)))
		(RETURN 1)))	;CLEARLY FITS ON LINE 
	(SETQ IDX 0)
	(SETQ HORIZ-POS 0)
	(SETQ LINE-COUNT 1)
   L	(COND ((NOT (< IDX STRING-LENGTH)) (RETURN LINE-COUNT)))
	(SETQ CHAR (FUNCALL STRING IDX))
	(COND ((ZEROP (LOGAND 200 CHAR)) (GO L1))	;SIMPLEMINDED FOR NOW
	      ((= CHAR 200) (RETURN LINE-COUNT)))
   L1	(SETQ HORIZ-POS (1+ HORIZ-POS))
	(COND ((NOT (< HORIZ-POS LINE-LENGTH))
		(SETQ LINE-COUNT (1+ LINE-COUNT))
		(SETQ HORIZ-POS 0)))
	(SETQ IDX (1+ IDX))
	(GO L)
))

;ARGS FOR EDITOR COMMANDS:
;  EDITOR COMMANDS MAY TAKE PREFIX "LOGICAL", NUMERIC, STRING ARGUMENTS, AND UP TO
;	TWO BUFFER POINTER 
;	ARGUMENTS.  THESE ARE PASSED IN THE SPECIAL VARIABLES ED-MODIFIER-FLAG,
;	ED-NUMERIC-ARG, ED-STRING-ARG, AND ED-POINTER-ARG-1 AND -2 RESPECTIVELY.
;  THESE VARIABLES ALSO SERVE TO RECEIVE RETURNED VALUES FROM EDITOR COMMANDS
;	IN SOME CASES AS FOLLOWS:  NORMALLY, AN EDITOR COMMAND IS ASSUMED TO "USE UP"
;	ALL ITS	ARGUMENTS.  THUS NORMALLY ALL THE ABOVE VARIABLES ARE RESET TO THEIR
;	"NULL" VALUES AFTER THE COMMAND RETURNS. HOWEVER, IF THE COMMAND
;	RETURNS MORE THAN ONE LISP VALUE, IT MEANS THAT THIS COMMAND IS
;	RETURNING SOME SORT(S) OF VALUE WHICH SHOULD BE SUPPLIED AS ARGUMENT
;	TO THE NEXT COMMAND.  THE TYPE OF VALUE AND THE PLACE ED-EXECUTE-COMMAND
;	SHOULD "FIND" IT ARE DECODED DEPENDING ON THE SECOND LISP VALUE
;	ED-EXECUTE-COMMAND RECEIVES.  
;	   IF THE SECOND VALUE RECEIVED IS:
;		'ALL, THE COMMAND HAS SET UP THE ARGUMENT VARIABLES EXACTLY AS
;			DESIRED AND THEY ARE NOT DISTURBED PRIOR TO CALLING THE
;			NEXT COMMAND.
;		'NUMBER  THE FIRST LISP VALUE IS PUT INTO ED-NUMERIC-ARG AND THE
;			OTHERS ARE RESET.
;		'STRING  THE FIRST LISP VALUE IS PUT INTO ED-STRING-ARG AND THE
;			OTHERS ARE RESET.
;		'BUFFER-POINTER THE FIRST LISP VALUE IS PUT INTO ED-POINTER-ARG-1.
;			THE OTHERS ARE RESET INCLUDING ED-POINTER-ARG-2.
;		'NEXT-BUFFER-POINTER ED-POINTER-ARG-1 IS MOVED TO ED-POINTER-ARG-2
;			THEN FIRST LISP VALUE IS STORED IN ED-POINTER-ARG-1 AND
;			THE OTHERS RESET.
;	THE "NULL" STATE FOR ALL ARGUMENT PASSING VARIABLES IS NIL, EXCEPT FOR
;		ED-NUMERIC-ARG IT IS 1.

(SPECIAL ED-EXIT-FLAG ED-MODIFIER-FLAG ED-NUMERIC-ARG ED-POINTER-ARG-1 
	 ED-POINTER-ARG-2 ED-STRING-ARG))

(DEFUN ED NIL
   (PROG (ED-EXIT-FLAG ED-MODIFIER-FLAG ED-NUMERIC-ARG ED-POINTER-ARG-1
	  ED-POINTER-ARG-2 ED-STRING-ARG)
	(SETQ ED-NUMERIC-ARG 1)
  L	(ED-EXECUTE-COMMAND (ED-GET-COMMAND))
	(COND (ED-EXIT-FLAG (RETURN ED-EXIT-FLAG)))
	(GO L)
))

(DEFUN ED-GET-COMMAND NIL 
   (PROG (CHAR TOP CONTROL META SHIFT SHIFT-LOCK ASCII-PART PRESET-CONTROL-BITS 
		TEM)
	(SETQ PRESET-CONTROL-BITS 0)
    L	(SETQ CHAR (ED-GET-COMMAND-CHARACTER))
	(SETQ TOP (LOGAND CHAR 4000))
	(SETQ SHIFT-LOCK (LOGAND CHAR 2000))
	(SETQ SHIFT (LOGAND CHAR 1000))
	(SETQ META (LOGAND CHAR 400))
	(SETQ CONTROL (LOGAND CHAR 200))
	(SETQ ASCII-PART (LOGAND CHAR 177))
	(COND ((SETQ TEM (ASSQ ASCII-PART '( (2 . 200)		;ALPHA
					     (3 . 400)		;BETA
					     (6 . 600) )))	;EPSILON
		(COND ((ZEROP (LOGAND (CDR TEM) PRESET-CONTROL-BITS))
			(SETQ PRESET-CONTROL-BITS 
				(LOGIOR PRESET-CONTROL-BITS (CDR TEM)))
			(GO L))
		      (T (SETQ PRESET-CONTROL-BITS 0)))))
	(SETQ PRESET-CONTROL-BITS (LOGIOR META (LOGIOR CONTROL PRESET-CONTROL-BITS)))
	(RETURN (LOGIOR PRESET-CONTROL-BITS ASCII-PART))
))

(DEFUN ED-GET-COMMAND-CHARACTER NIL 
	(IO-FS-TYI))

(DEFUN ED-EXECUTE-COMMAND (COMMAND-CHAR)
     (PROG (ED-CONTROL-FLAG ED-META-FLAG ED-COMMAND-ASCII-PART TEM 
	    VALUE VALUE-MODE)
	(SETQ ED-CONTROL-FLAG (LOGAND COMMAND-CHAR 200))
	(SETQ ED-META-FLAG (LOGAND COMMAND-CHAR 400))
	(SETQ ED-COMMAND-ASCII-PART (LOGAND COMMAND-CHAR 177))
	(COND ((= ED-COMMAND-ASCII-PART 177)
		(MULTIPLE-VALUE (VALUE VALUE-MODE) (ED-COMMAND-RUBOUT))
		(GO X))
	      ((AND (ZEROP ED-CONTROL-FLAG)
		    (ZEROP ED-META-FLAG))
		(MULTIPLE-VALUE (VALUE VALUE-MODE)
			 (ED-COMMAND-INSERT ED-COMMAND-ASCII-PART))
		(GO X))
	      ((SETQ TEM (ED-COMMAND-DISPATCH-TABLE 
				(- COMMAND-CHAR 200)))
		(MULTIPLE-VALUE (VALUE VALUE-MODE) (FUNCALL TEM COMMAND-CHAR))
		(GO X))
	      (T (PRINT 'UNDEFINED-COMMAND-CHAR)
		 (PRINT COMMAND-CHAR)
		 (GO X)))
   X	(RETURN (ED-INTERPRET-RETURNED-VALUE VALUE VALUE-MODE)) ))

(DEFUN ED-INTERPRET-RETURNED-VALUE (VALUE VALUE-MODE)
    (PROG (TEM) 
	(COND ((NULL VALUE-MODE) 
		(ED-COMMAND-RESET)
		(GO X))
	      ((EQ VALUE-MODE 'ALL)
		(GO X))
	      ((EQ VALUE-MODE 'NEXT-BUFFER-POINTER)
		(SETQ TEM ED-POINTER-ARG-1)
		(ED-COMMAND-RESET)
		(SETQ ED-POINTER-ARG-1 VALUE)
		(SETQ ED-POINTER-ARG-2 TEM)
		(GO X)))
	(ED-COMMAND-RESET)
	(COND ((EQ VALUE-MODE 'NUMBER)
		(SETQ ED-NUMERIC-ARG VALUE))
	      ((EQ VALUE-MODE 'STRING)
		(SETQ ED-STRING-ARG VALUE))
	      ((EQ VALUE-MODE 'BUFFER-POINTER)
		(SETQ ED-POINTER-ARG-1 VALUE))
	      (T (PRINT VALUE-MODE)
		 (PRINT 'UNKNOWN-VALUE-MODE)))
     X	(RETURN VALUE)
))

(DEFUN ED-COMMAND-RESET NIL 
	(SETQ ED-MODIFIER-FLAG NIL)
	(SETQ ED-POINTER-ARG-1 NIL)
	(SETQ ED-POINTER-ARG-2 NIL)
	(SETQ ED-STRING-ARG NIL)
	(SETQ ED-NUMERIC-ARG 1))

(DEFUN ED-COMMAND-INSERT (CHAR &OPTIONAL (BUFFER-POINTER 0))
  (PROG (CHAR-STRING)
	(COND ((NOT (= ED-NUMERIC-ARG 1)) (GO MULT)))
	(SETQ CHAR-STRING CHAR)	;NUMERIC "STRING" SERVES AS SINGLE CHARACTER OBJECT
   L	(ED-INSERT-STRING-AT-POINTER CHAR-STRING BUFFER-POINTER)
	(COND ((NOT (NUMBERP CHAR-STRING))
		(ADJUST-ARRAY-SIZE CHAR-STRING 0 ED-ARRAYS-AREA)))
	(RETURN T)
  MULT	(SETQ CHAR-STRING (MAKE-ARRAY-BLOCK ED-ARRAYS-AREA ART-STRING 
				(LIST ED-NUMERIC-ARG)
				NIL
				'(0)))
	(ALL-FILL CHAR-STRING CHAR)
	(GO L)
))

; ENTRY IS A FUNCTION TO BE CALLED WHEN CHAR SEEN. WHEN CALLED
; FROM MAIN DISPATCH, ITS CALLED WITH ONE ARG WHICH IS THE ACTUAL
; COMMAND CHARACTER ENCOUNTERED. (USEFUL IF MORE THAN ONE COMMAND
; DISPATCHES TO SAME PLACE.)

;600 LONG, CONTROL CHARS, META CHARS THEN CNTRL-META

(SETQ ED-INITIAL-COMMAND-DISPATCH-TABLE '(
;CONTROL CHARS
	NIL	;0 
	NIL	;1 
	NIL	;2 
	NIL	;3 
	NIL	;4 
	NIL	;5 
	NIL	;6 
	NIL	;7 
	NIL	;10 
	NIL	;11 
	NIL	;12 
	NIL	;13 
	NIL	;14 
	NIL	;15 
	NIL	;16 
	NIL	;17 
	NIL	;20 
	NIL	;21 
	NIL	;22 
	NIL	;23 
	NIL	;24 
	NIL	;25 
	NIL	;26 
	NIL	;27 
	NIL	;30 
	NIL	;31 
	NIL	;32 
	NIL	;33 
	NIL	;34 
	NIL	;35 
	NIL	;36 
	NIL	;37 
	NIL	;40   
	NIL	;41  !
	NIL	;42  "
	NIL	;43  #
	NIL	;44  $
	NIL	;45  %
	NIL	;46  &
	NIL	;47  '
	NIL	;50  (
	NIL	;51  )
	NIL	;52  *
	NIL	;53  +
	NIL	;54  ,
	NIL	;55  -
	NIL	;56  .
	NIL	;57  /
	NIL	;60  0
	NIL	;61  1
	NIL	;62  2
	NIL	;63  3
	NIL	;64  4
	NIL	;65  5
	NIL	;66  6
	NIL	;67  7
	NIL	;70  8
	NIL	;71  9
	NIL	;72  :
	NIL	;73  ;
	NIL	;74  <
	NIL	;75  =
	NIL	;76  >
	NIL	;77  ?
	NIL	;100  @
	NIL	;101  A
	NIL	;102  B
	NIL	;103  C
	NIL	;104  D
	NIL	;105  E
	NIL	;106  F
	NIL	;107  G
	NIL	;110  H
	NIL	;111  I
	NIL	;112  J
	NIL	;113  K
	NIL	;114  L
	NIL	;115  M
	NIL	;116  N
	NIL	;117  O
	NIL	;120  P
	NIL	;121  Q
	NIL	;122  R
	NIL	;123  S
	NIL	;124  T
	NIL	;125  U
	NIL	;126  V
	NIL	;127  W
	NIL	;130  X
	NIL	;131  Y
	NIL	;132  Z
	NIL	;133  [
	NIL	;134  \
	NIL	;135  ]
	NIL	;136  ^
	NIL	;137  _
	NIL	;140  `
	NIL	;141  a
	NIL	;142  b
	NIL	;143  c
	NIL	;144  d
	NIL	;145  e
	NIL	;146  f
	NIL	;147  g
	NIL	;150  h
	NIL	;151  i
	NIL	;152  j
	NIL	;153  k
	NIL	;154  l
	NIL	;155  m
	NIL	;156  n
	NIL	;157  o
	NIL	;160  p
	NIL	;161  q
	NIL	;162  r
	NIL	;163  s
	NIL	;164  t
	NIL	;165  u
	NIL	;166  v
	NIL	;167  w
	NIL	;170  x
	NIL	;171  y
	NIL	;172  z
	NIL	;173  {
	NIL	;174  |
	NIL	;175  }
	NIL	;176  ~
	NIL	;177  Š;META CHARS
	NIL	;0 
	NIL	;1 
	NIL	;2 
	NIL	;3 
	NIL	;4 
	NIL	;5 
	NIL	;6 
	NIL	;7 
	NIL	;10 
	NIL	;11 
	NIL	;12 
	NIL	;13 
	NIL	;14 
	NIL	;15 
	NIL	;16 
	NIL	;17 
	NIL	;20 
	NIL	;21 
	NIL	;22 
	NIL	;23 
	NIL	;24 
	NIL	;25 
	NIL	;26 
	NIL	;27 
	NIL	;30 
	NIL	;31 
	NIL	;32 
	NIL	;33 
	NIL	;34 
	NIL	;35 
	NIL	;36 
	NIL	;37 
	NIL	;40   
	NIL	;41  !
	NIL	;42  "
	NIL	;43  #
	NIL	;44  $
	NIL	;45  %
	NIL	;46  &
	NIL	;47  '
	NIL	;50  (
	NIL	;51  )
	NIL	;52  *
	NIL	;53  +
	NIL	;54  ,
	NIL	;55  -
	NIL	;56  .
	NIL	;57  /
	NIL	;60  0
	NIL	;61  1
	NIL	;62  2
	NIL	;63  3
	NIL	;64  4
	NIL	;65  5
	NIL	;66  6
	NIL	;67  7
	NIL	;70  8
	NIL	;71  9
	NIL	;72  :
	NIL	;73  ;
	NIL	;74  <
	NIL	;75  =
	NIL	;76  >
	NIL	;77  ?
	NIL	;100  @
	NIL	;101  A
	NIL	;102  B
	NIL	;103  C
	NIL	;104  D
	NIL	;105  E
	NIL	;106  F
	NIL	;107  G
	NIL	;110  H
	NIL	;111  I
	NIL	;112  J
	NIL	;113  K
	NIL	;114  L
	NIL	;115  M
	NIL	;116  N
	NIL	;117  O
	NIL	;120  P
	NIL	;121  Q
	NIL	;122  R
	NIL	;123  S
	NIL	;124  T
	NIL	;125  U
	NIL	;126  V
	NIL	;127  W
	NIL	;130  X
	NIL	;131  Y
	NIL	;132  Z
	NIL	;133  [
	NIL	;134  \
	NIL	;135  ]
	NIL	;136  ^
	NIL	;137  _
	NIL	;140  `
	NIL	;141  a
	NIL	;142  b
	NIL	;143  c
	NIL	;144  d
	NIL	;145  e
	NIL	;146  f
	NIL	;147  g
	NIL	;150  h
	NIL	;151  i
	NIL	;152  j
	NIL	;153  k
	NIL	;154  l
	NIL	;155  m
	NIL	;156  n
	NIL	;157  o
	NIL	;160  p
	NIL	;161  q
	NIL	;162  r
	NIL	;163  s
	NIL	;164  t
	NIL	;165  u
	NIL	;166  v
	NIL	;167  w
	NIL	;170  x
	NIL	;171  y
	NIL	;172  z
	NIL	;173  {
	NIL	;174  |
	NIL	;175  }
	NIL	;176  ~
	NIL	;177  Š;CONTROL-META CHARS
	NIL	;0 
	NIL	;1 
	NIL	;2 
	NIL	;3 
	NIL	;4 
	NIL	;5 
	NIL	;6 
	NIL	;7 
	NIL	;10 
	NIL	;11 
	NIL	;12 
	NIL	;13 
	NIL	;14 
	NIL	;15 
	NIL	;16 
	NIL	;17 
	NIL	;20 
	NIL	;21 
	NIL	;22 
	NIL	;23 
	NIL	;24 
	NIL	;25 
	NIL	;26 
	NIL	;27 
	NIL	;30 
	NIL	;31 
	NIL	;32 
	NIL	;33 
	NIL	;34 
	NIL	;35 
	NIL	;36 
	NIL	;37 
	NIL	;40   
	NIL	;41  !
	NIL	;42  "
	NIL	;43  #
	NIL	;44  $
	NIL	;45  %
	NIL	;46  &
	NIL	;47  '
	NIL	;50  (
	NIL	;51  )
	NIL	;52  *
	NIL	;53  +
	NIL	;54  ,
	NIL	;55  -
	NIL	;56  .
	NIL	;57  /
	NIL	;60  0
	NIL	;61  1
	NIL	;62  2
	NIL	;63  3
	NIL	;64  4
	NIL	;65  5
	NIL	;66  6
	NIL	;67  7
	NIL	;70  8
	NIL	;71  9
	NIL	;72  :
	NIL	;73  ;
	NIL	;74  <
	NIL	;75  =
	NIL	;76  >
	NIL	;77  ?
	NIL	;100  @
	NIL	;101  A
	NIL	;102  B
	NIL	;103  C
	NIL	;104  D
	NIL	;105  E
	NIL	;106  F
	NIL	;107  G
	NIL	;110  H
	NIL	;111  I
	NIL	;112  J
	NIL	;113  K
	NIL	;114  L
	NIL	;115  M
	NIL	;116  N
	NIL	;117  O
	NIL	;120  P
	NIL	;121  Q
	NIL	;122  R
	NIL	;123  S
	NIL	;124  T
	NIL	;125  U
	NIL	;126  V
	NIL	;127  W
	NIL	;130  X
	NIL	;131  Y
	NIL	;132  Z
	NIL	;133  [
	NIL	;134  \
	NIL	;135  ]
	NIL	;136  ^
	NIL	;137  _
	NIL	;140  `
	NIL	;141  a
	NIL	;142  b
	NIL	;143  c
	NIL	;144  d
	NIL	;145  e
	NIL	;146  f
	NIL	;147  g
	NIL	;150  h
	NIL	;151  i
	NIL	;152  j
	NIL	;153  k
	NIL	;154  l
	NIL	;155  m
	NIL	;156  n
	NIL	;157  o
	NIL	;160  p
	NIL	;161  q
	NIL	;162  r
	NIL	;163  s
	NIL	;164  t
	NIL	;165  u
	NIL	;166  v
	NIL	;167  w
	NIL	;170  x
	NIL	;171  y
	NIL	;172  z
	NIL	;173  {
	NIL	;174  |
	NIL	;175  }
	NIL	;176  ~
	NIL	;177  Š))
