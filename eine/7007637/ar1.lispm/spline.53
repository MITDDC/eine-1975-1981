;;-*-LISP-*-

;; Cubic splines in two dimensions using relaxed end conditions.

;; Algorithm is from "Mathematical Elements for Computer Graphics," by
;; Rogers and Adams,  page 220 ff.

;; "This technique has found application in computer-aided footwear design."
;;                              -- Rogers and Adams, p 132.

(declare (load '|ai:alan;lspenv fasl|))

(declare (macros t))

(defmacro ar$ (arr sub)
    `(arraycall flonum ,arr ,sub))

(defmacro as$ (val arr sub)
    `(store (arraycall flonum ,arr ,sub) ,val))

(defmacro for (var from to . body)
    (let ((gs (gensym)))
       `(do ((,var ,from (1+ ,var))
	     (,gs ,to))
	    ((> ,var ,gs))
	  (declare (fixnum ,var ,gs))
	  . ,body)))

(defmacro forstep (var from to step . body)
    (let ((gs (gensym)))
       `(do ((,var ,from (+$ ,step ,var))
	     (,gs ,to))
	    ((> ,var ,gs))
	  (declare (flonum ,var ,gs))
	  . ,body)))

(defmacro initarrays (size . vars)
    (do ((var vars (cdr var))
	 (body nil))
	((null var)
	 `(progn 'compile
		 (declare (special . ,vars))
		 . ,body))
      (push `(setq ,(car var) (array nil flonum ,size))
	    body)))


(initarrays 200 n1 n2 n3 bx by l ux uy)

(defun spline (n px py z cx cy)
   (declare (fixnum n z))
   (setq z (1+ z))

   ;; Begninning the "ENDPNT" subroutine.
   (as$ 1.0 n2 1)
   (as$ 0.5 n3 1)
   (for j 1 (1- n)
	(as$ (sqrt (+$ (expt (-$ (ar$ px (1+ j)) (ar$ px j)) 2)
		       (expt (-$ (ar$ py (1+ j)) (ar$ py j)) 2)))
	     l j))
   (let ((tem (//$ 3.0 (*$ 2.0 (ar$ l 1)))))
     (declare (flonum tem))
     (as$ (*$ tem (-$ (ar$ px 2) (ar$ px 1)))
	  bx 1)
     (as$ (*$ tem (-$ (ar$ py 2) (ar$ py 1)))
	  by 1))
   (as$ 2.0 n1 n)
   (as$ 4.0 n2 n)
   (let ((tem (//$ 6.0 (ar$ l (1- n)))))
     (declare (flonum tem))
     (as$ (*$ tem (-$ (ar$ px n) (ar$ px (1- n))))
	  bx n)
     (as$ (*$ tem (-$ (ar$ py n) (ar$ py (1- n))))
	  by n))
   
   ;; Beginning of "GAUSS" subroutine.
   (for j 2 (1- n)
	;; Create non-sero values for the internal rows of the M matrix.
	(as$ (ar$ l j) n1 j)
	(as$ (*$ 2.0 (+$ (ar$ l j) (ar$ l (1- j)))) n2 j)
	(as$ (ar$ l (1- j)) n3 j)
	;; Create rows 2 through N-1 of the B matrix.
	(let ((t1 (expt (ar$ l (1- j)) 2))
	      (t2 (expt (ar$ l j) 2))
	      (t3 (//$ 3.0 (*$ (ar$ l j) (ar$ l (1- j))))))
	  (declare (flonum t1 t2 t3))
	  (as$ (*$ t3 (+$ (*$ t1 (-$ (ar$ px (1+ j)) (ar$ px j)))
			  (*$ t2 (-$ (ar$ px j) (ar$ px (1- j))))))
	       bx j)
	  (as$ (*$ t3 (+$ (*$ t1 (-$ (ar$ py (1+ j)) (ar$ py j)))
			  (*$ t2 (-$ (ar$ py j) (ar$ py (1- j))))))
	       by j))
	)

   ;; The following is the Gaussian elimination.
   (for i 2 n
	(cond ((not (zerop (ar$ n1 i)))
	       ;; Normalize.
	       (let ((d (//$ (ar$ n2 (1- i)) (ar$ n1 i))))
		 (declare (flonum d))
		  ;; Reduce.
		  (as$ (-$ (*$ (ar$ n1 i) d) (ar$ n2 (1- i)))
		       n1 i)
		  (as$ (-$ (*$ (ar$ bx i) d) (ar$ bx (1- i)))
		       bx i)
		  (as$ (-$ (*$ (ar$ n2 i) d) (ar$ n3 (1- i)))
		       n2 i)
		  (as$ (-$ (*$ (ar$ by i) d) (ar$ by (1- i)))
		       by i)
		  (as$ (*$ (ar$ n3 i) d)
		       n3 i))
	       (let ((q (ar$ n2 i)))
		 (declare (flonum q))
		  ;; Normalize.
		  (as$ (//$ (ar$ n1 i) q)
		       n1 i)
		  (as$ (//$ (ar$ bx i) q)
		       bx i)
		  (as$ (//$ (ar$ n2 i) q)
		       n2 i)
		  (as$ (//$ (ar$ by i) q)
		       by i)
		  (as$ (//$ (ar$ n3 i) q)
		       n3 i)
		  ))))
   ;; Solve for unknown tangent vectors.
   (for j 0 (1- n)
	(let ((n-j (- n j)))
	  (declare (fixnum n-j))
	  (as$ (//$ (-$ (ar$ bx n-j)
			(*$ (ar$ n3 n-j) (ar$ ux (1+ n-j))))
		    (ar$ n2 n-j))
	       ux n-j)
	  (as$ (//$ (-$ (ar$ by n-j)
			(*$ (ar$ uy (1+ n-j)) (ar$ n3 n-j)))
		    (ar$ n2 n-j))
	       uy n-j)
	  ))

   ;; Beginning the "CURGEN" subroutine.
   (let ((i 1))
     (declare (fixnum i))
      (for j 1 (1- n)
	   (let ((l2 (expt (ar$ l j) 2)))
	     (declare (flonum l2))
	     (let ((3l2r (//$ 3.0 l2))
		   (-2l3r (//$ -2.0 (*$ l2 (ar$ l j))))
		   (tx (-$ (ar$ px (1+ j)) (ar$ px j)))
		   (ty (-$ (ar$ py (1+ j)) (ar$ py j)))
		   )
	       (declare (flonum 3l2r -2l3r tx ty))
	       (let ((f1x (ar$ px j))
		     (f1y (ar$ py j))
		     (f2x (ar$ ux j))
		     (f2y (ar$ uy j))
		     (f3x (-$ (*$ 3l2r tx)
			      (//$ (+$ (ar$ ux (1+ j)) (*$ 2.0 (ar$ ux j)))
				   (ar$ l j))))
		     (f3y (-$ (*$ 3l2r ty)
			      (//$ (+$ (ar$ uy (1+ j)) (*$ 2.0 (ar$ uy j)))
				   (ar$ l j))))
		     (f4x (+$ (*$ -2l3r tx)
			      (//$ (+$ (ar$ ux (1+ j)) (ar$ ux j))
				   l2)))
		     (f4y (+$ (*$ -2l3r ty)
			      (//$ (+$ (ar$ uy (1+ j)) (ar$ uy j))
				   l2))))
		 (declare (flonum f1x f1y f2x f2y f3x f3y f4x f4y))
		 (forstep tt 0.0 (ar$ l j) (//$ (ar$ l j) (float z))
			  (cond ((or (= j 1) (not (= tt 0.0)))
				 (as$ (+$ f1x (*$ tt f2x) (*$ tt tt f3x) (*$ tt tt tt f4x))
				      cx i)
				 (as$ (+$ f1y (*$ tt f2y) (*$ tt tt f3y) (*$ tt tt tt f4y))
				      cy i)
				 (setq i (1+ i))))
			  )
		 )))); end FOR J
   ))

;; General affine transformations.

(defun affine (x1 y1 x2 y2 x3 y3 x1p y1p x2p y2p x3p y3p x-list y-list)
    (declare (flonum x1 y1 x2 y2 x3 y3 x1p y1p x2p y2p x3p y3p))
    (let ((dn (+$ (*$ x1 (-$ y3 y2))
		   (-$ (*$ x2 y3))
		   (*$ x3 y2)
		   (*$ (-$ x2 x3) y1))))
      (declare (flonum dn))
      (let ((c (//$ (+$ (*$ x1 (-$ (*$ x3p y2) (*$ x2p y3)))
			(*$ x1p (-$ (*$ x2 y3) (*$ x3 y2)))
			(*$ (-$ (*$ x2p x3) (*$ x2 x3p)) y1))
		    dn))
	    (f (//$ (+$ (*$ x1 (-$ (*$ y2p y3) (*$ y2 y3p)))
			(*$ y1 (-$ (*$ x2 y3p) (*$ x3 y2p)))
			(-$ (*$ x2 y1p y3))
			(*$ x3 y1p y2))
		    dn))
	    (e (//$ (-$ (+$ (*$ x2 (-$ y3p y1p))
			    (*$ x1 (-$ y2p y3p))
			    (*$ x3 (-$ y1p y2p))))
		    dn))
	    (d (//$ (+$ (*$ y2 (-$ y3p y1p))
			(*$ y1 (-$ y2p y3p))
			(*$ y3 (-$ y1p y2p)))
		    dn))
	    (b (//$ (+$ (*$ x1 (-$ x3p x2p))
			(-$ (*$ x2 x3p))
			(*$ x2p x3)
			(*$ x1p (-$ x2 x3)))
		    dn))
	    (a (//$ (+$ (*$ x1p (-$ y3 y2))
			(-$ (*$ x2p y3))
			(* x3p y2)
			(* y1 (-$ x2p x3p)))
		    dn)))
	(declare (flonum a b c d e f))
	(do ((xl x-list (cdr xl))
	     (yl y-list (cdr yl))
	     (xpl nil)
	     (ypl nil))
	    ((null xl) (cons xpl ypl))
	  (let ((x (car xl)) (y (car yl)))
	    (declare (flonum x y))
	    (push (+$ (*$ a x) (*$ b y) c) xpl)
	    (push (+$ (*$ d x) (*$ e y) f) ypl))))))

(defun xform2 (x1 y1 x2 y2 x1p y1p x2p y2p x-list y-list)
    (declare (flonum x1 y1 x2 y2 x1p y1p x2p y2p))
    (let ((dn (-$ (+$ y1 x2) y2 x1)))
      (declare (flonum dn))
      (let ((b (//$ (-$ (+$ x2 x1p) x1 x2p) dn))
	    (d (//$ (-$ (+$ y2p y1) y2 y1p) dn))
	    (c (//$ (+$ (*$ x1 (-$ y2 x2p))
			(*$ x1p (-$ x2 y2))
			(*$ y1 (-$ x2p x2)))
		    dn))
	    (f (//$ (-$ (+$ (*$ x1 (-$ y2p y2))
			    (*$ y1 (-$ x2 y2p))
			    (*$ y1p y2)
			    (-$ (*$ x2 y1p))))
		    dn))
	    (e (//$ (-$ (+$ y2p x1) y1p x2) dn))
	    (a (//$ (-$ (+$ y1 x2p) y2 x1p) dn)))
	(declare (flonum a b c d e f))
	(do ((xl x-list (cdr xl))
	     (yl y-list (cdr yl))
	     (xpl nil)
	     (ypl nil))
	    ((null xl) (cons xpl ypl))
	  (let ((x (car xl)) (y (car yl)))
	       (declare (flonum x y))
	    (push (+$ (*$ a x) (*$ b y) c) xpl)
	    (push (+$ (*$ d x) (*$ e y) f) ypl))))))

(defun translate (x1 y1 x1p y1p x-list y-list)
   (do ((xl x-list (cdr xl))
	(yl y-list (cdr yl))
	(dx (-$ x1p x1))
	(dy (-$ y1p y1))
	(xpl nil)
	(ypl nil))
       ((null xl) (cons xpl ypl))
     (declare (flonum dx dy))
     (let ((x (car xl)) (y (car yl)))
       (declare (flonum x y))
       (push (+$ x dx) xpl)
       (push (+$ y dy) ypl))))


(declare (*expr knight-keyboard smallscreen draw-tv-line drawmode))
(declare (special xor ior))
(declare (special top-tty bottom-tty))
(declare (notype (draw-tv-line fixnum fixnum fixnum fixnum)))
(declare (notype (drawmode fixnum)))
(declare (notype (draw-cross fixnum fixnum fixnum)))

(defun spline-init ()
    (load '|ai:tvlisp;tvout fasl|)
    (load '|ai:tvlisp;tvline fasl|)
    (load '|ai:gls;kk fasl|)
    (load '|ai:liblsp;split fasl|)
    (splitscreen 12.)
    (knight-keyboard)
    )

(defun draw-crosses (x-list y-list size)
   (do ((xp x-list (cdr xp))
	(yp y-list (cdr yp)))
       ((null xp))
    (let ((x (fix (car xp)))
	  (y (fix (car yp))))
      (draw-cross x y size))))

(defun draw-cross (x y size)
    (drawmode xor)
    (draw-tv-line (- x size) y (+ x size) y)
    (draw-tv-line x (- y size) x (+ y size))
    (drawmode ior))

(defun run ()
    (let ((x-list nil)
	  (y-list nil)
	  (ll 0)
	  (xa nil) (ya nil)
	  (z 0) (zx nil) (zy nil)
	  )
       (declare (fixnum ll))
       (terpri)
       (princ '|Type in pairs of X and Y coords, ending with a NIL.|)
       (terpri)
       (princ '|They should be coords that fit on the tv screen.|)
       (terpri)
       (do ((a)) (())
	 (setq a (read))
	 (or a (return nil))
	 (push (float a) x-list)
	 (push (float (read)) y-list)
	 (draw-cross (fix (car x-list)) (fix (car y-list)) 5)
	 (terpri))
       (setq ll (length x-list))
       (setq xa (array nil flonum (1+ ll))
	     ya (array nil flonum (1+ ll)))
       (fillarray xa (cons 0.0 x-list))
       (fillarray ya (cons 0.0 y-list))
       (princ '|How many intermediate points per segment? |)
       (setq z (read))
       (terpri)
       (setq zx (array nil flonum (+ ll (* (1- ll) z) 1))
	     zy (array nil flonum (+ ll (* (1- ll) z) 1)))
       (spline ll xa ya z zx zy)
       (drawmode xor)
       (do ((xx (cdr (listarray zx)) (cdr xx))
	    (yy (cdr (listarray zy)) (cdr yy)))
	   ((null (cdr xx)))
	 (draw-tv-line (fix (car xx)) (fix (car yy))
		       (fix (cadr xx)) (fix (cadr yy))))
       (drawmode ior)
       nil))

(declare (special draw-x-list draw-y-list))
(declare (special draw-xa draw-ya draw-resolution draw-rxa draw-rya))
(declare (special xpos ypos))

(setq draw-resolution 10)

(defun draw-init (res)
    (setq draw-xa (array nil flonum 100)
	  draw-ya (array nil flonum 100))
    (setq draw-rxa (array nil flonum (* 100 res))
	  draw-rxa (array nil flonum (* 100 res)))
    (setq draw-resolution res))

(defun draw ()
    (draw-init draw-resolution)
    (setq xpos (// 576. 2.) ypos 100.)
    (do ((char 0)
	 )
      (declare (fixnum char))
      (setq char (tyi))
      (cond ((or (= char 117) (= char 157))		;O = Object.
	     (get-object))
	    ((and (> char 60) (< char 64))		;1,2,3 = Transform
	     (transform (- char 60)))
	    ((or (= char 103) (= char 143))		;C = Clear
	     (cursorpos 'c top-tty))
	    ((or (= char 122) (= char 162))
	     (princ '|Resolution is now |)
	     (princ draw-resolution) (terpri)
	     (princ '|New resolution? |)
	     (let ((r (read)))
		(and r (setq draw-resolution r))))
	    (t (princ '| ???|) (terpri)))
      ))

;; This command "gets" the object from the user.
(defun get-object ()
    (let ((c (get-points nil)))
      (setq draw-x-list (car c)
	    draw-y-list (cdr c))
      (draw-spline draw-x-list draw-y-list)))


(defun draw-spline (x-list y-list)
   (let ((pts (length draw-x-list)))
     (declare (fixnum pts))
     (fillarray draw-xa x-list)
     (fillarray draw-ya y-list)
     (spline pts draw-xa draw-ya draw-resolution draw-rxa draw-rya)
     (drawmode xor)
     (do ((end (+ (* draw-resolution (1- pts)) pts))
	  (i 1 (1+ i)))
	 ((= i end))
       (declare (fixnum i))
       (draw-tv-line (fix (ar$ draw-rxa i))
		     (fix (ar$ draw-rya i))
		     (fix (ar$ draw-rxa (1+ i)))
		     (fix (ar$ draw-rya (1+ i)))))
     (drawmode ior)
     ))

(defun get-points (num)
    (drawmode xor)
    (do ((x-list)
	 (y-list)
	 (char)
	 (lowchar)
	 (mult)
	 (ssize 10)
	 (move nil nil)
	 )
      (nil)
      (declare (fixnum char lowchar mult ssize))
      (curse xpos ypos)
      (setq char (tyi))
      (curse xpos ypos)
      (setq lowchar (logand 177 char))
      (and (> lowchar 140) (< lowchar 173)
	   (setq lowchar (- lowchar 40)))
      (setq mult (lsh char -7))
      (cond ((or (= lowchar 133) (= lowchar 173))
	     (setq move t xpos (- xpos (* mult ssize))))
	    ((or (= lowchar 135) (= lowchar 175))
	     (setq move t xpos (+ xpos (* mult ssize))))
	    ((or (= lowchar 134) (=lowchar 174))
	     (setq move t ypos (- ypos (* mult ssize))))
	    ((or (= lowchar 57) (= lowchar 16))
	     (setq move t ypos (- ypos (* mult ssize))))
	    ((or (= lowchar 40) (= lowchar 53))
	     (push (float xpos) x-list)
	     (push (float ypos) y-list)
	     (draw-cross xpos ypos 7)
	     (cond ((and num (not (< (length x-list) num)))
		    (drawmode ior)
		    (return (cons (nreverse x-list) (nreverse y-list))))))
	    ((= lowchar 177)
	     (cond (x-list
		    (draw-cross (fix (car x-list)) (fix (car y-list)) 7)
		    (setq x-list (cdr x-list) y-list (cdr y-list)))))
	    ((= lowchar 15)
	     (drawmode ior)
	     (return (cons (nreverse x-list) (nreverse y-list))))
	    )
      ))

(defun transform (n)
    (princ n) (princ '| point transformation.  Provide |)
    (princ (+ n n)) (princ '| points.|) (terpri)
    (let ((l (get-points (+ n n))))
      (let ((ans (selectq n
		    (1 (translate (car x) (car y) (cadr x) (cadr y) draw-x-list draw-y-list))
		    (2 (xform2 (car x) (car y) (cadr x) (cadr y) (caddr x) (caddr y)
			       (cadddr x) (cadddr y) draw-x-list draw-y-list))
		    (3 (affine (car x) (car y) (cadr x) (cadr y) (caddr x) (caddr y)
			       (cadddr x) (cadddr y) (car (cddddr x)) (car (cddddr y))
			       (cadr (cddddr x)) (cadr (cddddr y)) draw-x-list draw-y-list)))))
	(draw-spline (car ans) (cdr ans)))))